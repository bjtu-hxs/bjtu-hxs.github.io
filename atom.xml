<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TriaL</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-30T01:22:09.819Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BJTU-HXS</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode——[141]Linked List Cycle环形链表</title>
    <link href="http://yoursite.com/2019/03/30/leetcode-141/"/>
    <id>http://yoursite.com/2019/03/30/leetcode-141/</id>
    <published>2019-03-30T01:22:09.000Z</published>
    <updated>2019-03-30T01:22:09.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><p><strong>进阶：</strong></p><p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p><a id="more"></a><p>Given a linked list, determine if it has a cycle in it.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1], pos = -1</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><p><strong>Follow up:</strong></p><p>Can you solve it using <em>O(1)</em> (i.e. constant) memory?</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>使用快慢指针，快指针fast一次循环比慢指针slow多走一步，如果存在环，则快慢指针总会相遇。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Method 1 1ms 72.81%</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;-1&lt;/code&gt;，则在该链表中没有环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head = [3,2,0,-4], pos = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：链表中有一个环，其尾部连接到第二个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head = [1,2], pos = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：链表中有一个环，其尾部连接到第一个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head = [1], pos = -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：链表中没有环。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你能用 &lt;em&gt;O(1)&lt;/em&gt;（即，常量）内存解决此问题吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode——[125]Valid Palindrome验证回文串</title>
    <link href="http://yoursite.com/2019/03/21/leetcode-125/"/>
    <id>http://yoursite.com/2019/03/21/leetcode-125/</id>
    <published>2019-03-21T03:38:55.000Z</published>
    <updated>2019-03-21T03:38:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><a id="more"></a><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p><strong>Note:</strong> For the purpose of this problem, we define empty string as valid palindrome.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;race a car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>头尾扫描，借用<code>getCharType</code>方法判断字符的类型，非数字字母字符则跳过，大写字母则转化为小写字母，从而获得头尾两个数字字母类型字符。然后判断头尾字符是否相等，不相等则返回<code>False</code>，直到头尾相遇返回<code>True</code>。这段代码跑了<strong>6ms</strong>，超过了<strong>92.68%</strong>的Java提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Method 1 6ms 92.68%</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> head = <span class="number">0</span>, tail = s.length() - <span class="number">1</span>; head &lt; tail; head++, tail--)&#123;</span><br><span class="line">            <span class="keyword">while</span> (getCharType(chars[head]) == <span class="number">2</span>) &#123;</span><br><span class="line">                head++;</span><br><span class="line">                <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                chars[head] = chars[head];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (getCharType(chars[tail]) == <span class="number">2</span>) &#123;</span><br><span class="line">                tail--;</span><br><span class="line">                <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                chars[tail] = chars[tail];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (getCharType(chars[head]) == <span class="number">1</span>) &#123;</span><br><span class="line">                chars[head] += <span class="string">'a'</span> - <span class="string">'A'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (getCharType(chars[tail]) == <span class="number">1</span>) &#123;</span><br><span class="line">                chars[tail] += <span class="string">'a'</span> - <span class="string">'A'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (chars[head] != chars[tail]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCharType</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span> || (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="共勉"><a href="#共勉" class="headerlink" title="共勉"></a>共勉</h1><p>今日事，今日毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;本题中，我们将空字符串定义为有效的回文串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;A man, a plan, a canal: Panama&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;race a car&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode——[326]Power of Three3的幂</title>
    <link href="http://yoursite.com/2019/03/04/leetcode-326/"/>
    <id>http://yoursite.com/2019/03/04/leetcode-326/</id>
    <published>2019-03-04T09:15:48.000Z</published>
    <updated>2019-03-21T02:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 27</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 45</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能不使用循环或者递归来完成本题吗？</p><a id="more"></a><p>Given an integer, write a function to determine if it is a power of three.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 27</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 0</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 45</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong><br>Could you do it without using any loop / recursion?</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>试试递归，先确定递归推出条件，取小于3的值，1返回True，其余返回False；对于大于等于3的值，不能被3整除也返回False，能被3整除的进行递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">3</span> != <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> recursion(n / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recursion(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码可以简化一下，小于0直接返回False，大于0判断是否能被3整除，能就进行递归，否则判断是否等于1。这段代码跑了<strong>84ms</strong>，超过了<strong>64.07%</strong>的Java提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Method1 84ms 64.07%</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> recursion(n / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recursion(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>把递归改写为循环，这里的转化十分简单，递归调用改为循环判断是否能被3整除就好了，这段代码跑了<strong>15ms</strong>，超过了<strong>95.47%</strong>的Java提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Method2 15ms 95.47%</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n = n / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><p>观察一下，假设一个素数$a$，那么$a$的幂均为$X=a^n$，其中$n&gt;=0$，$X$的因子只有一个数$a$，则能整除$X$的非负整数只有$a^m$，其中$0&lt;m\leq n$，均为$a$的幂，负数肯定不会是$a$的幂；对于一个非素数$b$，假设$b=i*j$，那么它的幂均为$Y=(ij)^n$，其中$n\geq0$，$Y$的因子有$i$和$j$两个，则能整除$Y$的是这样的数$Z=i^pj^q$，其中$0&lt;p\leq n,0&lt;q\leq n$，当$p$不一定等于$q$时，所以$Z$不一定为$b$的幂。</p><p>所以对于3，它是个素数，我们只需要判断参数n是否能整除int型范围内最大的3的幂1162261467。这段代码跑了<strong>13ms</strong>，超过了<strong>100%</strong>的Java提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Method3 13ms 100%</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个整数，写一个函数来判断它是否是 3 的幂次方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 4:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;br&gt;你能不使用循环或者递归来完成本题吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>配置Spark不同任务driver日志输出到不同文件</title>
    <link href="http://yoursite.com/2018/12/21/divide-driver-log/"/>
    <id>http://yoursite.com/2018/12/21/divide-driver-log/</id>
    <published>2018-12-21T06:35:20.000Z</published>
    <updated>2018-12-21T06:36:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>配置Spark不同任务driver日志输出到不同文件</p><p>第一步：配置log4j.properties输出文件名设为一个占位符：</p><p><code>log4j.appender.DRFA.File=log/${logfilename}.log</code></p><p>第二步：在spark-submit时传递一个参数：</p><p><code>—driver-java-options &quot;-Dlogfilename=${JOB_NAME}&quot;</code></p><p>通过设置JOB_NAME的值来动态设置任务log输出文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;配置Spark不同任务driver日志输出到不同文件&lt;/p&gt;
&lt;p&gt;第一步：配置log4j.properties输出文件名设为一个占位符：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;log4j.appender.DRFA.File=log/${logfilename}.log&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="Spark" scheme="http://yoursite.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>xcrun: error: invalid active developer path错误解决方案</title>
    <link href="http://yoursite.com/2018/11/05/xrun-error-solution/"/>
    <id>http://yoursite.com/2018/11/05/xrun-error-solution/</id>
    <published>2018-11-04T16:55:37.000Z</published>
    <updated>2018-11-04T16:55:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>更新MacOS后，使用Git命令时报错：</p><p><code>xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</code></p><p>使用如下命令解决：</p><p><code>xcode-select --install</code></p><p>这是由于每次更新Mac系统Xcode都会被卸载，Mac中Git是基于Xcode line tools运行的，使用其他依赖Xcode line tools的工具应该也会出现同样的错误，所以更新完系统之后记得重装一次Xcode呀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更新MacOS后，使用Git命令时报错：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /L
      
    
    </summary>
    
    
      <category term="MacOS" scheme="http://yoursite.com/tags/MacOS/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>初尝itchat</title>
    <link href="http://yoursite.com/2018/06/15/have-a-taste-of-itchat/"/>
    <id>http://yoursite.com/2018/06/15/have-a-taste-of-itchat/</id>
    <published>2018-06-15T07:18:01.000Z</published>
    <updated>2018-06-15T07:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天又是熊熊烈日的一天啊，只能宅在空调房里刷刷知乎。发现了一个好玩的Python接口——“itchat，它是一个开源的微信个人号接口，使用python调用微信从未如此简单”，这是官网的介绍啦。这个是<a href="https://github.com/littlecodersh/ItChat" target="_blank" rel="noopener">itchat的Github地址</a>，接下来便看看文档进行了一些恶趣味测试，从骚扰基友到变身聊天机器人，统计微信好友信息，最后总结出我为什么单身。</p><a id="more"></a><h1 id="从骚扰基友到变身聊天机器人"><a href="#从骚扰基友到变身聊天机器人" class="headerlink" title="从骚扰基友到变身聊天机器人"></a>从骚扰基友到变身聊天机器人</h1><p>仔细思考一哈，骚扰基友主要有三步：登录、获取目标、发送消息。嗯，可以开始了。</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登录有<strong>itchat.login()</strong>和<strong>itchat.auto_login()</strong>两种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"></span><br><span class="line">itchat.login()  <span class="comment"># 登录微信，会弹出一个二维码，扫描登录网页版微信</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"></span><br><span class="line">itchat.auto_login(hotReload=<span class="keyword">True</span>)  <span class="comment"># 第一次需要扫码，之后只需要手机端确认登录</span></span><br></pre></td></tr></table></figure><h2 id="获取特定好友"><a href="#获取特定好友" class="headerlink" title="获取特定好友"></a>获取特定好友</h2><p>我们要给好友发送消息，首先需要获取好友列表，然后从中选择想要发送消息的好友。使用<strong>itchat.get_friends()</strong>抓取好友列表，然后使用<strong>itchat.search_friends()</strong>获取特定的好友，这里使用备注名获取好友，然后取满足要求的第一个好友。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">friends = itchat.get_friends(update=<span class="keyword">True</span>)[<span class="number">0</span>:]  <span class="comment"># 爬取微信好友</span></span><br><span class="line"></span><br><span class="line">names = itchat.search_friends(remarkName=<span class="string">'remarkName'</span>)  <span class="comment"># 返回备注名为‘remarkName’的用户列表，可选的参数还有昵称nickName，微信号wechatAccount，唯一标识符userName</span></span><br><span class="line"></span><br><span class="line">target = names[<span class="number">0</span>]  <span class="comment"># 取列表第一个User对象，其实都是字典，属性有userName、昵称、微信号、备注名、头像url等</span></span><br></pre></td></tr></table></figure><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>发送消息主要使用<strong>itchat.send()</strong>方法，发送的内容可以是很多种形式，包括text、img、video、file，发送成功返回True，失败返回False。对于不同的消息内容也分别有对应的方法，比如send_msg()、send_file()、send_img、send_video()，但官网推荐使用<strong>send()</strong>。下面是发送消息的代码例子，最后注释部分是群发所有好友，谨慎使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">itchat.send(<span class="string">'Hello remarkName, I love U more than I can say!'</span>, toUserName=target[<span class="string">'UserName'</span>])  <span class="comment"># 发消息咯，第二个参数为userName，特定的一串hash码</span></span><br><span class="line">itchat.send(<span class="string">'你今天怎么这么奇怪？'</span>, toUserName=target[<span class="string">'UserName'</span>])  </span><br><span class="line">itchat.send(<span class="string">'怪可爱的！'</span>, toUserName=target[<span class="string">'UserName'</span>]) </span><br><span class="line"></span><br><span class="line"><span class="comment"># # 给所有好友发送消息</span></span><br><span class="line"><span class="comment"># for friend in friends[1:]:  # friends第一个元素为自己，所以去掉</span></span><br><span class="line"><span class="comment">#     itchat.send(friend['RemarkName']+',好久不联系了，甚是想念~', toUserName=friend['UserName'])</span></span><br></pre></td></tr></table></figure><h2 id="骚扰一下"><a href="#骚扰一下" class="headerlink" title="骚扰一下"></a>骚扰一下</h2><p>结合上面三部分代码，就可以开始打扰一下啦，全部代码如下，<strong>需要修改remarkName为目标备注名</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"></span><br><span class="line">itchat.auto_login(hotReload=<span class="keyword">True</span>)  <span class="comment"># 第一次需要扫码，之后只需要手机端确认登录</span></span><br><span class="line"></span><br><span class="line">friends = itchat.get_friends(update=<span class="keyword">True</span>)[<span class="number">0</span>:]  <span class="comment"># 爬取微信好友</span></span><br><span class="line"></span><br><span class="line">names = itchat.search_friends(remarkName=<span class="string">'remarkName'</span>)  <span class="comment"># 返回备注名为‘remarkName’的用户列表，可选的参数还有昵称nickName，userName</span></span><br><span class="line"></span><br><span class="line">target = names[<span class="number">0</span>]  <span class="comment"># 取列表第一个User对象，其实都是字典，属性有昵称、userName、微信号、备注名、头像url等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发消息咯，第二个参数为userName，特定的一串hash码</span></span><br><span class="line">itchat.send(<span class="string">'Hello remarkName, I love U more than I can say!'</span>, toUserName=target[<span class="string">'UserName'</span>])  </span><br><span class="line">itchat.send(<span class="string">'你今天怎么这么奇怪？'</span>, toUserName=target[<span class="string">'UserName'</span>])  </span><br><span class="line">itchat.send(<span class="string">'怪可爱的！'</span>, toUserName=target[<span class="string">'UserName'</span>])  </span><br><span class="line"></span><br><span class="line"><span class="comment"># # 给所有好友发送消息</span></span><br><span class="line"><span class="comment"># for friend in friends[1:]:  # friends第一个元素为自己，所以去掉</span></span><br><span class="line"><span class="comment">#     itchat.send(friend['RemarkName']+',好久不联系了，甚是想念~', toUserName=friend['UserName'])</span></span><br></pre></td></tr></table></figure><p>首先给同在宿舍的A君来一发：</p><p><img src="/images/have-a-taste-of-itchat/first.jpg" alt=""></p><p>可以，认真复习的男人真是高冷，只能靠发红包来联系感情了，那就给在图书馆自习顺便看妹的H哥来一发吧：</p><p><img src="/images/have-a-taste-of-itchat/second.jpg" alt=""></p><p>欸，果然没有认真自习，秒回。试试我们的好朋友，小哪吒X吧：</p><p><img src="/images/have-a-taste-of-itchat/third.jpg" alt=""></p><p>啊，没想到被小哪吒反撩了，我果然还是<strong>太年轻</strong>。</p><h2 id="实现一个聊天机器人"><a href="#实现一个聊天机器人" class="headerlink" title="实现一个聊天机器人"></a>实现一个聊天机器人</h2><p>这个时候，就想要实现一个自动聊天的机器人了。首先套用官方的自动回复模版，然后重写自己想要修改的方法，各个方法的作用我都写在了注释里，模版如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itchat, time</span><br><span class="line"><span class="keyword">from</span> itchat.content <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register([TEXT, MAP, CARD, NOTE, SHARING])  # 消息内容为文本、地图、名片、通知、分享类型时的回复方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text_reply</span><span class="params">(msg)</span>:</span></span><br><span class="line">    msg.user.send(<span class="string">'%s: %s'</span> % (msg.type, msg.text))</span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register([PICTURE, RECORDING, ATTACHMENT, VIDEO])  # 消息为图片、语言、附件、视频的回复方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_files</span><span class="params">(msg)</span>:</span></span><br><span class="line">    msg.download(msg.fileName)</span><br><span class="line">    typeSymbol = &#123;</span><br><span class="line">        PICTURE: <span class="string">'img'</span>,</span><br><span class="line">        VIDEO: <span class="string">'vid'</span>, &#125;.get(msg.type, <span class="string">'fil'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'@%s@%s'</span> % (typeSymbol, msg.fileName)</span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register(FRIENDS)  # 好友邀请类型回复方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_friend</span><span class="params">(msg)</span>:</span></span><br><span class="line">    msg.user.verify()</span><br><span class="line">    msg.user.send(<span class="string">'Nice to meet you!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register(TEXT, isGroupChat=True)  # 群消息类型回复方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text_reply</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> msg.isAt:</span><br><span class="line">        msg.user.send(<span class="string">u'@%s\u2005I received: %s'</span> % (</span><br><span class="line">            msg.actualNickName, msg.text))</span><br><span class="line"></span><br><span class="line">itchat.auto_login(<span class="keyword">True</span>)  <span class="comment"># 登录</span></span><br><span class="line">itchat.run(<span class="keyword">True</span>)  <span class="comment"># 运行</span></span><br></pre></td></tr></table></figure><p>模板回复Text的方法就是直接回复消息类型加消息内容，十分简单，就像小时候跟小伙伴拌嘴，你说啥他就说啥怼你，就很无聊。所以准备先修改这个方法实现自己想要的效果，哈哈哈哈哈，结果写的时候，用旧手机号注册一个小号debug太频繁，被Web微信封了，两周后解封。</p><p><img src="/images/have-a-taste-of-itchat/mengbi.jpg" alt=""></p><p>所以就放弃按自己想法写的计划了，直接套用这个<a href="https://github.com/xiaoxiaoyao/MyApp/blob/master/PythonApplication1/%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B0%8F%E7%BB%83%E4%B9%A0/itchat-tuling123.com-xiaobing.py" target="_blank" rel="noopener">开源的聊天机器人项目</a>，这个小项目是调用了图灵机器人的API，这个是<a href="https://www.kancloud.cn/turing/web_api/522992" target="_blank" rel="noopener">API的调用文档</a>。在回复文本信息的方法中，调用一个<strong>get_tuling_reply()</strong>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@itchat.msg_register([TEXT, MAP, CARD, NOTE, SHARING])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text_reply</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="comment"># print(type(msg.user))</span></span><br><span class="line">    <span class="comment"># print(msg.user['NickName'])</span></span><br><span class="line">    msg.user.send(get_tuling_reply(msg))</span><br></pre></td></tr></table></figure><p>get_tuling_reply()的代码，这个方法用来传递msg消息调用图灵机器人API，并处理图灵机器人不好使的异常情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tuling_reply</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="comment"># 如果图灵Key出现问题，那么reply将会是None</span></span><br><span class="line">    reply = get_response(msg[<span class="string">'Text'</span>])</span><br><span class="line">    <span class="comment"># a or b的意思是，如果a有内容，那么返回a，否则返回b， 为了保证在图灵Key出现问题的时候仍旧可以回复，这里设置一个默认回复</span></span><br><span class="line">    <span class="keyword">return</span> reply <span class="keyword">or</span> <span class="string">'I received: '</span> + msg.get(<span class="string">'Text'</span>)</span><br></pre></td></tr></table></figure><p>其中调用了一个get_response()方法，这个方法就是用来调用图灵机器人API的，用来获取msg的回复内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(msg)</span>:</span></span><br><span class="line">    url = <span class="string">'http://www.tuling123.com/openapi/api'</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">'key'</span>: <span class="string">'75137612d89c42f0b9d7a3f5133ec656'</span>,  <span class="comment"># 这个key可以直接拿来用，随便用，无所谓，放心公开</span></span><br><span class="line">        <span class="string">'info'</span>: msg,  <span class="comment"># 传递好友发送的消息</span></span><br><span class="line">        <span class="string">'userid'</span>: <span class="string">'pth-robot'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.post(url, data=data).json()  <span class="comment"># 接收图灵机器人返回的json文件</span></span><br><span class="line">        <span class="keyword">return</span> r.get(<span class="string">'text'</span>)  <span class="comment"># 返回图灵机器人回复的文本内容</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>到这Text部分的修改就完成了，下面是autoreply.py的全部代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> itchat.content <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(msg)</span>:</span></span><br><span class="line">    url = <span class="string">'http://www.tuling123.com/openapi/api'</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">'key'</span>: <span class="string">'75137612d89c42f0b9d7a3f5133ec656'</span>,  <span class="comment"># 这个key可以直接拿来用，随便用，无所谓，放心公开</span></span><br><span class="line">        <span class="string">'info'</span>: msg,</span><br><span class="line">        <span class="string">'userid'</span>: <span class="string">'pth-robot'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.post(url, data=data).json()</span><br><span class="line">        <span class="keyword">return</span> r.get(<span class="string">'text'</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tuling_reply</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="comment"># 如果图灵Key出现问题，那么reply将会是None</span></span><br><span class="line">    reply = get_response(msg[<span class="string">'Text'</span>])</span><br><span class="line">    <span class="comment"># a or b的意思是，如果a有内容，那么返回a，否则返回b， 为了保证在图灵Key出现问题的时候仍旧可以回复，这里设置一个默认回复</span></span><br><span class="line">    <span class="keyword">return</span> reply <span class="keyword">or</span> <span class="string">'I received: '</span> + msg.get(<span class="string">'Text'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register([TEXT, MAP, CARD, NOTE, SHARING])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text_reply</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="comment"># print(type(msg.user))</span></span><br><span class="line">    <span class="comment"># print(msg.user['NickName'])</span></span><br><span class="line">    msg.user.send(get_tuling_reply(msg))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register([PICTURE, RECORDING, ATTACHMENT, VIDEO])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_files</span><span class="params">(msg)</span>:</span></span><br><span class="line">    msg.download(msg.fileName)</span><br><span class="line">    type_symbol = &#123;</span><br><span class="line">        PICTURE: <span class="string">'img'</span>,</span><br><span class="line">        VIDEO: <span class="string">'vid'</span>, &#125;.get(msg.type, <span class="string">'fil'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'@%s@%s'</span> % (type_symbol, msg.fileName)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register(FRIENDS)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_friend</span><span class="params">(msg)</span>:</span></span><br><span class="line">    msg.user.verify()</span><br><span class="line">    <span class="comment"># print(type(msg.user))</span></span><br><span class="line">    <span class="comment"># print(msg.user)</span></span><br><span class="line">    msg.user.send(<span class="string">'终于等到你!'</span>)  <span class="comment"># 在这做了简单的修改，本来是想回复带NickName的，但是NickName为空报错了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register(TEXT, isGroupChat=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text_reply</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> msg.isAt:</span><br><span class="line">        msg.user.send(<span class="string">u'@%s\u2005I received: %s'</span> % (</span><br><span class="line">            msg.actualNickName, msg.text))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">itchat.auto_login(<span class="keyword">True</span>)</span><br><span class="line">itchat.run()</span><br></pre></td></tr></table></figure><p>代码写好了，自然要看看效果呀，就冒着被封号的危险用大号尝试了一下，用小号给大号发消息，效果截图：</p><p><img src="/images/have-a-taste-of-itchat/chat-robot.jpg" alt=""></p><p>嗨呀，这么会撩，要不就用大号一直挂着好了。</p><p><img src="/images/have-a-taste-of-itchat/bye-to-solo.png" alt=""></p><h1 id="统计微信好友数据"><a href="#统计微信好友数据" class="headerlink" title="统计微信好友数据"></a>统计微信好友数据</h1><p>这部分主要联系一下Python画图，统计一下好友性别分布，地区分布和创建个性签名关键词云，从而在一定程度上反映我单身的原因。最后将所有好友头像拼接成一张大图，看起来不错。</p><h2 id="爬取数据"><a href="#爬取数据" class="headerlink" title="爬取数据"></a>爬取数据</h2><p>统计对象是数据，首先需要爬取数据嘛，然后保存下来。先定一个主函数，登录Web微信，爬取好友信息保存到friends中，跟获取特定好友的步骤一样，然后遍历friends，将所有好友信息保存到一个list中，然后分别调用保存信息方法和下载头像方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    itchat.auto_login(hotReload=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    friends = itchat.get_friends(update=<span class="keyword">True</span>)[<span class="number">1</span>:]  <span class="comment"># 获取好友信息，除了自己</span></span><br><span class="line">    friends_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> friend <span class="keyword">in</span> friends:</span><br><span class="line">        item = &#123;<span class="string">'NickName'</span>: friend[<span class="string">'NickName'</span>], <span class="string">'HeadImgUrl'</span>: friend[<span class="string">'HeadImgUrl'</span>], <span class="string">'Sex'</span>: sex_dict[str(friend[<span class="string">'Sex'</span>])],</span><br><span class="line">                <span class="string">'Province'</span>: friend[<span class="string">'Province'</span>], <span class="string">'Signature'</span>: friend[<span class="string">'Signature'</span>], <span class="string">'UserName'</span>: friend[<span class="string">'UserName'</span>]&#125;</span><br><span class="line">        friends_list.append(item)  <span class="comment"># list添加当前好友信息</span></span><br><span class="line">        <span class="comment"># print(item)</span></span><br><span class="line"></span><br><span class="line">    save_data(friends_list)  <span class="comment"># 将好友信息写入json文件</span></span><br><span class="line">    download_images(friends_list)  <span class="comment"># 下载好友头像</span></span><br></pre></td></tr></table></figure><p>然后是保存好友信息的方法，需要加载os、codecs、json模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存好友信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span><span class="params">(friend_list)</span>:</span></span><br><span class="line">    data_dir = <span class="string">'./data/'</span>  <span class="comment"># 创建目录</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(data_dir):</span><br><span class="line">        os.mkdir(data_dir)</span><br><span class="line">    out_file_name = <span class="string">"./data/friends.json"</span></span><br><span class="line">    print(<span class="string">'begin to save friends data'</span>)</span><br><span class="line">    <span class="keyword">with</span> codecs.open(out_file_name, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">        json_file.write(json.dumps(friend_list, ensure_ascii=<span class="keyword">False</span>))  <span class="comment"># 写入文件</span></span><br><span class="line">    print(<span class="string">'end process'</span>)</span><br></pre></td></tr></table></figure><p>下载头像的方法，需要加载os模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载好友头像</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_images</span><span class="params">(frined_list)</span>:</span></span><br><span class="line">    image_dir = <span class="string">"./images/"</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(image_dir):  <span class="comment"># 创建目录</span></span><br><span class="line">        os.mkdir(image_dir)</span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    print(<span class="string">'begin to save friend avatar'</span>)</span><br><span class="line">    <span class="keyword">for</span> friend <span class="keyword">in</span> frined_list:  <span class="comment"># 遍历保存头像</span></span><br><span class="line">        image_name = str(num) + <span class="string">'.jpg'</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        img = itchat.get_head_img(userName=friend[<span class="string">"UserName"</span>])</span><br><span class="line">        <span class="keyword">with</span> open(image_dir + image_name, <span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(img)  <span class="comment"># 保存当前头像</span></span><br><span class="line">    print(<span class="string">'end process'</span>)</span><br></pre></td></tr></table></figure><p>综合起来代码如下，添加了一个字典，将json中代表性别的1、2转化为男、女：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">sex_dict = &#123;<span class="string">'0'</span>: <span class="string">"其他"</span>, <span class="string">'1'</span>: <span class="string">"男"</span>, <span class="string">'2'</span>: <span class="string">"女"</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载好友头像</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_images</span><span class="params">(frined_list)</span>:</span></span><br><span class="line">    image_dir = <span class="string">"./images/"</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(image_dir):</span><br><span class="line">        os.mkdir(image_dir)</span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    print(<span class="string">'begin to save friend avatar'</span>)</span><br><span class="line">    <span class="keyword">for</span> friend <span class="keyword">in</span> frined_list:</span><br><span class="line">        image_name = str(num) + <span class="string">'.jpg'</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        img = itchat.get_head_img(userName=friend[<span class="string">"UserName"</span>])</span><br><span class="line">        <span class="keyword">with</span> open(image_dir + image_name, <span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(img)</span><br><span class="line">    print(<span class="string">'end process'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存好友信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span><span class="params">(friend_list)</span>:</span></span><br><span class="line">    data_dir = <span class="string">'./data/'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(data_dir):</span><br><span class="line">        os.mkdir(data_dir)</span><br><span class="line">    out_file_name = <span class="string">"./data/friends.json"</span></span><br><span class="line">    print(<span class="string">'begin to save friends data'</span>)</span><br><span class="line">    <span class="keyword">with</span> codecs.open(out_file_name, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">        json_file.write(json.dumps(friend_list, ensure_ascii=<span class="keyword">False</span>))</span><br><span class="line">    print(<span class="string">'end process'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    itchat.auto_login(hotReload=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    friends = itchat.get_friends(update=<span class="keyword">True</span>)[<span class="number">1</span>:]  <span class="comment"># 获取好友信息，除了自己</span></span><br><span class="line">    friends_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> friend <span class="keyword">in</span> friends:</span><br><span class="line">        item = &#123;<span class="string">'NickName'</span>: friend[<span class="string">'NickName'</span>], <span class="string">'HeadImgUrl'</span>: friend[<span class="string">'HeadImgUrl'</span>], <span class="string">'Sex'</span>: sex_dict[str(friend[<span class="string">'Sex'</span>])],</span><br><span class="line">                <span class="string">'Province'</span>: friend[<span class="string">'Province'</span>], <span class="string">'Signature'</span>: friend[<span class="string">'Signature'</span>], <span class="string">'UserName'</span>: friend[<span class="string">'UserName'</span>]&#125;</span><br><span class="line"></span><br><span class="line">        friends_list.append(item)  <span class="comment"># list添加当前好友信息</span></span><br><span class="line">        <span class="comment"># print(item)</span></span><br><span class="line"></span><br><span class="line">    save_data(friends_list)  <span class="comment"># 将好友信息写入json文件</span></span><br><span class="line">    download_images(friends_list)  <span class="comment"># 下载好友头像</span></span><br></pre></td></tr></table></figure><p>跑一次就可以得到想要的数据咯。</p><h2 id="男女比例"><a href="#男女比例" class="headerlink" title="男女比例"></a>男女比例</h2><p>首先做一个简单的统计，得到我的票圈男女比例。首先加载数据Json文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in_file_name = <span class="string">'./data/friends.json'</span></span><br><span class="line"><span class="keyword">with</span> codecs.open(in_file_name, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    friends = json.load(f)</span><br></pre></td></tr></table></figure><p>然后对性别进行统计，使用collections中的Counter来进行计数。然后使用pyecharts进行画图，因为pyecharts需要的参数为list，而sex_counter是一个字典，所以先把它转化为两个list。转化后调用get_pie()得到饼状图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sex_counter = Counter()  <span class="comment"># 性别</span></span><br><span class="line"><span class="keyword">for</span> friend <span class="keyword">in</span> friends:</span><br><span class="line">    sex_counter[friend[<span class="string">'Sex'</span>]] += <span class="number">1</span>  <span class="comment"># 统计性别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 性别</span></span><br><span class="line">name_list, num_list = dict2list(sex_counter)</span><br><span class="line">get_pie(<span class="string">'性别统计'</span>, name_list, num_list)</span><br></pre></td></tr></table></figure><p>dict2list()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict2list</span><span class="params">(_dict)</span>:</span></span><br><span class="line">    name_list = []  <span class="comment"># 性别种类，男、女、其他</span></span><br><span class="line">    num_list = []  <span class="comment"># 对应数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> _dict.items():  <span class="comment"># 添加到list中</span></span><br><span class="line">        name_list.append(key)</span><br><span class="line">        num_list.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name_list, num_list  <span class="comment"># 返回两个list</span></span><br></pre></td></tr></table></figure><p>get_pie()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pie</span><span class="params">(item_name, item_name_list, item_num_list)</span>:</span></span><br><span class="line">    totle = item_num_list[<span class="number">0</span>] + item_num_list[<span class="number">1</span>] + item_num_list[<span class="number">2</span>]</span><br><span class="line">    subtitle = <span class="string">"共有:%d个好友"</span> % totle</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化一个饼状图</span></span><br><span class="line">    pie = Pie(item_name, page_title=item_name, title_text_size=<span class="number">30</span>, title_pos=<span class="string">'center'</span>, \</span><br><span class="line">              subtitle=subtitle, subtitle_text_size=<span class="number">25</span>, width=<span class="number">800</span>, height=<span class="number">800</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 往饼状图添加数据</span></span><br><span class="line">    pie.add(<span class="string">""</span>, item_name_list, item_num_list, is_label_show=<span class="keyword">True</span>, center=[<span class="number">50</span>, <span class="number">45</span>], radius=[<span class="number">0</span>, <span class="number">50</span>], \</span><br><span class="line">            legend_pos=<span class="string">'left'</span>, legend_orient=<span class="string">'vertical'</span>, label_text_size=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存饼状图</span></span><br><span class="line">    analyse_path = <span class="string">'./analyse/'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(analyse_path):</span><br><span class="line">        os.mkdir(analyse_path)</span><br><span class="line"></span><br><span class="line">    out_file_name = analyse_path + item_name + <span class="string">'.html'</span></span><br><span class="line">    <span class="comment"># print(out_file_name)</span></span><br><span class="line">    pie.render(out_file_name)</span><br></pre></td></tr></table></figure><p>全部代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> Pie</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pie</span><span class="params">(item_name, item_name_list, item_num_list)</span>:</span></span><br><span class="line">    totle = item_num_list[<span class="number">0</span>] + item_num_list[<span class="number">1</span>] + item_num_list[<span class="number">2</span>]</span><br><span class="line">    subtitle = <span class="string">"共有:%d个好友"</span> % totle</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化一个饼状图</span></span><br><span class="line">    pie = Pie(item_name, page_title=item_name, title_text_size=<span class="number">30</span>, title_pos=<span class="string">'center'</span>, \</span><br><span class="line">              subtitle=subtitle, subtitle_text_size=<span class="number">25</span>, width=<span class="number">800</span>, height=<span class="number">800</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 往饼状图添加数据</span></span><br><span class="line">    pie.add(<span class="string">""</span>, item_name_list, item_num_list, is_label_show=<span class="keyword">True</span>, center=[<span class="number">50</span>, <span class="number">45</span>], radius=[<span class="number">0</span>, <span class="number">50</span>], \</span><br><span class="line">            legend_pos=<span class="string">'left'</span>, legend_orient=<span class="string">'vertical'</span>, label_text_size=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存饼状图</span></span><br><span class="line">    analyse_path = <span class="string">'./analyse/'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(analyse_path):</span><br><span class="line">        os.mkdir(analyse_path)</span><br><span class="line"></span><br><span class="line">    out_file_name = analyse_path + item_name + <span class="string">'.html'</span></span><br><span class="line">    <span class="comment"># print(out_file_name)</span></span><br><span class="line">    pie.render(out_file_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict2list</span><span class="params">(_dict)</span>:</span></span><br><span class="line">    name_list = []  <span class="comment"># 性别种类，男、女、其他</span></span><br><span class="line">    num_list = []  <span class="comment"># 对应数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> _dict.items():  <span class="comment"># 添加到list中</span></span><br><span class="line">        name_list.append(key)</span><br><span class="line">        num_list.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name_list, num_list  <span class="comment"># 返回两个list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    in_file_name = <span class="string">'./data/friends.json'</span></span><br><span class="line">    <span class="keyword">with</span> codecs.open(in_file_name, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        friends = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 待统计参数</span></span><br><span class="line">    sex_counter = Counter()  <span class="comment"># 性别</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> friend <span class="keyword">in</span> friends:</span><br><span class="line">        <span class="comment"># 统计性别</span></span><br><span class="line">        sex_counter[friend[<span class="string">'Sex'</span>]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 性别</span></span><br><span class="line">    name_list, num_list = dict2list(sex_counter)</span><br><span class="line">    get_pie(<span class="string">'性别统计'</span>, name_list, num_list)</span><br></pre></td></tr></table></figure><p>跑一次就可以得到好友饼状图啦，可以看出男性好友数量为女性好友数量的1.5倍，还有6.19%的没有备注性别的好友，我果然是个死直男。</p><p><img src="/images/have-a-taste-of-itchat/gender-rate.png" alt=""></p><h2 id="好友省份分布"><a href="#好友省份分布" class="headerlink" title="好友省份分布"></a>好友省份分布</h2><p>与男女比例代码差不多，就直接贴代码了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> Bar</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> Grid</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> Map</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bar</span><span class="params">(item_name, item_name_list, item_num_list)</span>:</span></span><br><span class="line">    bar = Bar(item_name, page_title=item_name, title_text_size=<span class="number">30</span>, title_pos=<span class="string">'center'</span>)</span><br><span class="line"></span><br><span class="line">    bar.add(<span class="string">""</span>, item_name_list, item_num_list, title_pos=<span class="string">'center'</span>, xaxis_interval=<span class="number">0</span>, xaxis_rotate=<span class="number">27</span>, \</span><br><span class="line">            xaxis_label_textsize=<span class="number">20</span>, yaxis_label_textsize=<span class="number">20</span>, yaxis_name_pos=<span class="string">'end'</span>, yaxis_pos=<span class="string">"%50"</span>)</span><br><span class="line">    bar.show_config()</span><br><span class="line"></span><br><span class="line">    grid = Grid(width=<span class="number">1300</span>, height=<span class="number">800</span>)</span><br><span class="line">    grid.add(bar, grid_top=<span class="string">"13%"</span>, grid_bottom=<span class="string">"23%"</span>, grid_left=<span class="string">"15%"</span>, grid_right=<span class="string">"15%"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存柱状图</span></span><br><span class="line">    analyse_path = <span class="string">'./analyse/'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(analyse_path):</span><br><span class="line">        os.mkdir(analyse_path)</span><br><span class="line">    out_file_name = analyse_path + item_name + <span class="string">'.html'</span></span><br><span class="line">    grid.render(out_file_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为只取前15个人数最多的省份，Counter返回的是一个list，所以转化方法不一样</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter2list</span><span class="params">(_counter)</span>:</span>  </span><br><span class="line">    name_list = []</span><br><span class="line">    num_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> _counter:</span><br><span class="line">        name_list.append(item[<span class="number">0</span>])</span><br><span class="line">        num_list.append(item[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name_list, num_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    in_file_name = <span class="string">'./data/friends.json'</span></span><br><span class="line">    <span class="keyword">with</span> codecs.open(in_file_name, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        friends = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 待统计参数</span></span><br><span class="line">    Province_counter = Counter()  <span class="comment"># 省份</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> friend <span class="keyword">in</span> friends:</span><br><span class="line">        <span class="comment"># 省份</span></span><br><span class="line">        <span class="keyword">if</span> friend[<span class="string">'Province'</span>] != <span class="string">""</span>:</span><br><span class="line">            Province_counter[friend[<span class="string">'Province'</span>]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 省份前15</span></span><br><span class="line">    name_list, num_list = counter2list(Province_counter.most_common(<span class="number">15</span>))</span><br><span class="line">    get_bar(<span class="string">'地区统计'</span>, name_list, num_list)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/have-a-taste-of-itchat/province-distribution.png" alt=""></p><h2 id="签名云"><a href="#签名云" class="headerlink" title="签名云"></a>签名云</h2><p>基本步骤与上面一样，主要需要使用一个叫做jieba的分词包来进行中文分词，然后发现出现了class、emoji、span等词，所以先把它们去除掉，再进行分词，也就是去除停用词。</p><p><img src="/images/have-a-taste-of-itchat/sig-cloud-01.png" alt=""></p><p>全部代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">word_cloud</span><span class="params">(item_name, item_name_list, item_num_list, word_size_range)</span>:</span></span><br><span class="line">    wordcloud = WordCloud(width=<span class="number">1400</span>, height=<span class="number">900</span>)</span><br><span class="line"></span><br><span class="line">    wordcloud.add(<span class="string">""</span>, item_name_list, item_num_list, word_size_range=word_size_range, shape=<span class="string">'pentagon'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存云图</span></span><br><span class="line">    analyse_path = <span class="string">'./analyse/'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(analyse_path):</span><br><span class="line">        os.mkdir(analyse_path)</span><br><span class="line">    out_file_name = analyse_path + item_name + <span class="string">'.html'</span></span><br><span class="line">    wordcloud.render(out_file_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tag</span><span class="params">(text, cnt)</span>:</span></span><br><span class="line">    print(<span class="string">'正在分析句子:'</span>, text)</span><br><span class="line">    tag_list = jieba.analyse.extract_tags(text)  <span class="comment"># jieba分词</span></span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> tag_list:</span><br><span class="line">        cnt[tag] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter2list</span><span class="params">(_counter)</span>:</span></span><br><span class="line">    name_list = []</span><br><span class="line">    num_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> _counter:</span><br><span class="line">        name_list.append(item[<span class="number">0</span>])</span><br><span class="line">        num_list.append(item[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name_list, num_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    in_file_name = <span class="string">'./data/friends.json'</span></span><br><span class="line">    <span class="keyword">with</span> codecs.open(in_file_name, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        friends = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 待统计参数</span></span><br><span class="line">    Signature_counter = Counter()  <span class="comment"># 个性签名关键词</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> friend <span class="keyword">in</span> friends:</span><br><span class="line">        <span class="comment"># 出去停用词，emoji、class、span</span></span><br><span class="line">        signature = friend[<span class="string">"Signature"</span>].strip().replace(<span class="string">"span"</span>, <span class="string">""</span>).replace(<span class="string">"class"</span>, <span class="string">""</span>).replace(<span class="string">"emoji"</span>, <span class="string">""</span>)</span><br><span class="line">        <span class="comment"># 签名关键词提取</span></span><br><span class="line">        get_tag(signature, Signature_counter)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 微信好友签名前200个关键词</span></span><br><span class="line">    name_list, num_list = counter2list(Signature_counter.most_common(<span class="number">200</span>))</span><br><span class="line">    word_cloud(<span class="string">'微信好友签名关键词'</span>, name_list, num_list, [<span class="number">20</span>, <span class="number">100</span>])</span><br></pre></td></tr></table></figure><p>最终结果如下，在一堆向上和小清新的关键字里面，让我眼前一亮的居然是第二行的dotaer，我果然是凭实力单的身。</p><p><img src="/images/have-a-taste-of-itchat/sig-cloud-02.png" alt=""></p><h2 id="合成头像"><a href="#合成头像" class="headerlink" title="合成头像"></a>合成头像</h2><p>最后将所有好友头像聚合为一张图，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> PIL.Image</span><br><span class="line"></span><br><span class="line">print(<span class="string">"正在合成头像"</span>)</span><br><span class="line"><span class="comment"># 对用户头像进行压缩</span></span><br><span class="line">photo_width = <span class="number">200</span></span><br><span class="line">photo_height = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像路径list</span></span><br><span class="line">photo_path_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前路径</span></span><br><span class="line">dirName = os.getcwd() + <span class="string">'/images'</span></span><br><span class="line"><span class="comment"># print(dirName)</span></span><br><span class="line"><span class="comment"># 遍历文件夹获取所有图片的路径</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(dirName):</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"jpg"</span> <span class="keyword">in</span> file:</span><br><span class="line">            photo_path_list.append(os.path.join(root, file))</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(photo_path_list)</span></span><br><span class="line">pic_num = len(photo_path_list)</span><br><span class="line"><span class="comment"># 每行每列显示图片数量</span></span><br><span class="line">line_max = int(math.sqrt(pic_num))</span><br><span class="line">row_max = int(math.sqrt(pic_num))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> line_max &gt; <span class="number">20</span>:</span><br><span class="line">    line_max = <span class="number">20</span></span><br><span class="line">    row_max = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">pic_max = line_max * row_max</span><br><span class="line"></span><br><span class="line">toImage = PIL.Image.new(<span class="string">'RGBA'</span>, (photo_width * line_max, photo_height * row_max))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, row_max):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, line_max):</span><br><span class="line"></span><br><span class="line">        pic_fole_head = PIL.Image.open(photo_path_list[num])</span><br><span class="line">        width, height = pic_fole_head.size</span><br><span class="line"></span><br><span class="line">        tmppic = pic_fole_head.resize((photo_width, photo_height))</span><br><span class="line"></span><br><span class="line">        loc = (int(j % row_max * photo_width), int(i % row_max * photo_height))</span><br><span class="line">        toImage.paste(tmppic, loc)</span><br><span class="line">        num = num + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num &gt;= len(photo_path_list):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> num &gt;= pic_max:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(toImage.size)</span><br><span class="line">toImage.save(<span class="string">'./analyse/merged.png'</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/have-a-taste-of-itchat/merged.png" alt=""></p><h1 id="Python包清单"><a href="#Python包清单" class="headerlink" title="Python包清单"></a>Python包清单</h1><p>本文全过程在Python3环境下进行，主要依赖包如下：</p><ul><li>pillow: pip install pillow</li><li>pyecharts: pip install pyecharts</li><li>itchat: pip install itchat</li><li>jieba: pip install jieba</li></ul><h1 id="我为什么单身"><a href="#我为什么单身" class="headerlink" title="我为什么单身"></a>我为什么单身</h1><p>可能是太帅了吧，哈哈哈，</p><p>应该是太厚脸皮了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天又是熊熊烈日的一天啊，只能宅在空调房里刷刷知乎。发现了一个好玩的Python接口——“itchat，它是一个开源的微信个人号接口，使用python调用微信从未如此简单”，这是官网的介绍啦。这个是&lt;a href=&quot;https://github.com/littlecodersh/ItChat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;itchat的Github地址&lt;/a&gt;，接下来便看看文档进行了一些恶趣味测试，从骚扰基友到变身聊天机器人，统计微信好友信息，最后总结出我为什么单身。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客Next主题添加统计文章阅读量功能</title>
    <link href="http://yoursite.com/2018/06/12/leancloud-config/"/>
    <id>http://yoursite.com/2018/06/12/leancloud-config/</id>
    <published>2018-06-11T17:39:43.000Z</published>
    <updated>2018-06-11T17:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近学的很无聊，就又想折腾一下我稚嫩的Blog，零零总总写了三十多篇文章，虽然都是辣鸡，但还是想做一个统计，能够在主页观察到每篇文章的阅读量，能直观看到哪怕一点点增量，那也能带来很大的满足感啊。于是Google了一下，在一个叫<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">Doublemine</a>的博客上发现原来Next主题支持一个叫LeanCloud的云服务商提供的统计功能，于是便做了一点微小的工作，达到了下面的效果。这篇教程在<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">Doublemine</a>的博客已经很详细，但是LeanCloud的UI进行了不小的更新，一些功能布局发生了变化，所以索性就根据新的UI再写一篇辣鸡博文。</p><p><img src="/images/leancloud-config/time-of-reading.png" alt=""></p><a id="more"></a><h1 id="Get-LeanCloud服务"><a href="#Get-LeanCloud服务" class="headerlink" title="Get LeanCloud服务"></a>Get LeanCloud服务</h1><h2 id="注册LeanCloud帐号"><a href="#注册LeanCloud帐号" class="headerlink" title="注册LeanCloud帐号"></a>注册LeanCloud帐号</h2><p>首先要注册一个帐号，访问<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud官网</a>，点击免费试用，或者访问控制台都会进入登录/注册页面，直接注册就好，也可以直接第三方账号登录，不过登录之后还是需要绑定邮箱和手机号。</p><p><img src="/images/leancloud-config/leancloud.png" alt=""></p><p><img src="/images/leancloud-config/login-page.png" alt=""></p><h2 id="配置LeanCloud端"><a href="#配置LeanCloud端" class="headerlink" title="配置LeanCloud端"></a>配置LeanCloud端</h2><p>有了帐号了，就是一名可以行使权力的正经用户了，那就开始配置Cloud，来为我们的Blog统计功能创建一个新应用吧。然后需要为统计阅读量创建一个表，然后得到应用的app-id与app-key，用来配置我们的Next实现统计功能。</p><ul><li>进入控制台，点击创建应用，这个test开发版是我已经创建的应用：</li></ul><p><img src="/images/leancloud-config/console.png" alt=""></p><ul><li>就命名为test吧，然后选择开发版（免费哒），然后创建，就会像上一张图一样有一个test开发版的应用：</li></ul><p><img src="/images/leancloud-config/create-app.png" alt=""></p><ul><li>点进test开发版，为统计阅读量单独创建一个Class，就是在数据库中建一个表，首先点击存储，然后创建Class，Next要求Class名称必须为Counter，所以命名一定要为Counter，为了防止阅读量统计不准确，建议ACL权限设置为无限制，然后点击创建Class。就会像我的数据库一样，除了一些带下划线_的表之外，还有一个Counter表：</li></ul><p><img src="/images/leancloud-config/create-class.png" alt=""></p><h2 id="设置网络安全"><a href="#设置网络安全" class="headerlink" title="设置网络安全"></a>设置网络安全</h2><p>由于app-id和app-key是完全暴露的，所以防止他人使用，我们可以在应用设置里面面设置Web安全域名，只有添加的域名才能使用该应用，防止有人Hack我们的数据库。点击设置，安全中心，Web域名安全，添加Blog域名，点击保存就OK了。</p><p><img src="/images/leancloud-config/web-security.png" alt=""></p><h1 id="配置博客端"><a href="#配置博客端" class="headerlink" title="配置博客端"></a>配置博客端</h1><h2 id="配置-config-yml文件"><a href="#配置-config-yml文件" class="headerlink" title="配置_config.yml文件"></a>配置_config.yml文件</h2><p>首先需要得到LeanCloud应用的app-id与app-key，在控制台，设置，应用key中就可以找到：</p><p><img src="/images/leancloud-config/app-id-and-key.png" alt=""></p><p>然后配置就很简单了，只需要修改Next主题的配置文件_config.yml，该文件在blog/themes/next路径下，blog为你的博客文件夹，打开配置文件，找到LeanCloud配置项，修改为可用，添加对应app-id和app-key就行：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># You can visit https://leancloud.cn get AppID and AppKey.</span></span><br><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  app_id:</span> <span class="comment"># 你的app-id </span></span><br><span class="line"><span class="attr">  app_key:</span> <span class="comment"># 你的app-key</span></span><br></pre></td></tr></table></figure><p>然后使用命令<code>hexo generate</code>重新生成Blog，<code>hexo deploy</code>部署到Github就OK了，就可以达到本文第一张图的效果：</p><p><img src="/images/leancloud-config/time-of-reading.png" alt=""></p><p>点击某篇文章之后，还可以在数据库中看到生成的数据记录：</p><p><img src="/images/leancloud-config/db-data.png" alt=""></p><h2 id="伪造阅读量"><a href="#伪造阅读量" class="headerlink" title="伪造阅读量"></a>伪造阅读量</h2><p>如果想要达到装逼的目的，可以在数据库中更改上面那张图的time，即访问量，比如我将第二条记录改为10w：</p><p><img src="/images/leancloud-config/zhuangbi.png" alt=""></p><p>就可以在Blog中看到效果：</p><p><img src="/images/leancloud-config/result.png" alt=""></p><p>当然，作为一个<strong>老实人</strong>，我当然还是实事求是地把它改回了1。</p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>感觉博客背景一片白不太好，截的图跟Markdown背景融为一体了，很影响阅读体验，准备下次搞一下背景。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;最近学的很无聊，就又想折腾一下我稚嫩的Blog，零零总总写了三十多篇文章，虽然都是辣鸡，但还是想做一个统计，能够在主页观察到每篇文章的阅读量，能直观看到哪怕一点点增量，那也能带来很大的满足感啊。于是Google了一下，在一个叫&lt;a href=&quot;https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Doublemine&lt;/a&gt;的博客上发现原来Next主题支持一个叫LeanCloud的云服务商提供的统计功能，于是便做了一点微小的工作，达到了下面的效果。这篇教程在&lt;a href=&quot;https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Doublemine&lt;/a&gt;的博客已经很详细，但是LeanCloud的UI进行了不小的更新，一些功能布局发生了变化，所以索性就根据新的UI再写一篇辣鸡博文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/leancloud-config/time-of-reading.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>leetcode——[021]Merge Two Sorted Lists合并两个有序链表</title>
    <link href="http://yoursite.com/2018/06/11/leetcode-021/"/>
    <id>http://yoursite.com/2018/06/11/leetcode-021/</id>
    <published>2018-06-11T02:26:11.000Z</published>
    <updated>2019-03-21T02:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><a id="more"></a><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>与合并有序数组策略一致，先将前部分进行比较，直至有一个数组的元素都处理完，然后结果链表的尾节点next指向另一个数组剩下的节点就OK了。这段代码跑了<strong>15ms</strong>，超过了<strong>95.97%</strong>的Java提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Method_01  15ms  95.97%</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);  <span class="comment">// 头结点，不含有效值</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                cur = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                cur = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;  <span class="comment">// 处理剩下的节点</span></span><br><span class="line">            cur.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode——[206]Reverse Linked List反转链表</title>
    <link href="http://yoursite.com/2018/06/09/leetcode-206/"/>
    <id>http://yoursite.com/2018/06/09/leetcode-206/</id>
    <published>2018-06-09T02:57:10.000Z</published>
    <updated>2019-03-21T02:35:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>反转一个单链表。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><a id="more"></a><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>题目要求使用迭代和递归两种方法，首先是迭代。迭代过程主要是用三个指针，next保留当前节点head的下一个节点，pre保留上一个节点，将head.next指向pre，然后pre指向head(head已经成为下一次迭代的pre)，head指向next。迭代到最后一个节点后，尾节点变为头节点，将head.next指向pre。这段代码跑了<strong>0ms</strong>，超过了<strong>100.00%</strong>的Java提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Method_01  0ms  100.00%</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;  <span class="comment">// 边界判断</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="keyword">while</span>(head.next != <span class="keyword">null</span>) &#123;  <span class="comment">// 迭代过程</span></span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = pre;  <span class="comment">// 处理尾节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归如下，耗时耗空间，这段代码跑了<strong>1ms</strong>，超过了<strong>21.74%</strong>的Java提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Method_02  1ms  21.74%</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode newListNode = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newListNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;反转一个单链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;br&gt;你可以迭代或递归地反转链表。你能否用两种方法解决这道题？&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode——[019]Remove Nth Node From End of List删除链表倒数第N个节点</title>
    <link href="http://yoursite.com/2018/06/08/leetcode-019/"/>
    <id>http://yoursite.com/2018/06/08/leetcode-019/</id>
    <published>2018-06-08T02:25:39.000Z</published>
    <updated>2019-03-21T02:33:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><a id="more"></a><p>Given a linked list, remove the <em>n</em>-th node from the end of list and return its head.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>Given <em>n</em> will always be valid.</p><p><strong>Follow up:</strong></p><p>Could you do this in one pass?</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>题目要求一趟扫描实现，可以使用双指针，cur指向当前访问到的节点，要删除倒数第n个节点，先从第一个节点遍历到第n + 1个节点。如果链表只有n个节点，则cur为空，则直接返回头结点的下一个节点<code>head.next</code>；如果cur不为空，则说明不止n个节点，这时使用一个新的指针pre指向第一个结点，这样pre与cur刚好相距n个节点，循环遍历到cur指向链表尾节点，则pre指向了要删除的节点的前一个节点，<code>pre.next = pre.next.next</code>实现删除倒数第n个节点。这段代码跑了<strong>10ms</strong>，超过了95.16%的Java提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Method_01  10ms  95.16%</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head;  <span class="comment">//遍历指针</span></span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;   <span class="comment">// 如果已经为链表尾节点，直接返回第二个节点</span></span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = head;  <span class="comment">// 与cur相距n个节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) &#123; <span class="comment">// 循环至cur指向链表尾节点</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = pre.next.next; <span class="comment">// 删除目标节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;  <span class="comment">// 返回头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个链表，删除链表的倒数第 &lt;em&gt;n&lt;/em&gt; 个节点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定的 &lt;em&gt;n&lt;/em&gt; 保证是有效的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你能尝试使用一趟扫描实现吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode——[278]First Bad Version第一个错误的版本</title>
    <link href="http://yoursite.com/2018/06/07/leetcode-278/"/>
    <id>http://yoursite.com/2018/06/07/leetcode-278/</id>
    <published>2018-06-07T11:51:25.000Z</published>
    <updated>2019-03-21T02:36:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 n = 5，并且 version = 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></table></figure><a id="more"></a><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p><p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p><p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given n = 5, and version = 4 is the first bad version.</span><br><span class="line"></span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>题目要求调用isBadVersion次数越少越好，很明显采取二分查找策略，需要注意的是，在进行取中点时，可以使用<code>int mid = left + (right - left) / 2；</code>的小技巧来防止数据类型溢出。这段代码跑了<strong>14ms</strong>，超过了<strong>100.00%</strong>的Java提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Method_01  14ms  100.00%</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="comment">// 边界判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;  <span class="comment">// 二分查找，防止溢出</span></span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。&lt;/p&gt;
&lt;p&gt;假设你有 &lt;code&gt;n&lt;/code&gt; 个版本 &lt;code&gt;[1, 2, ..., n]&lt;/code&gt;，你想找出导致之后所有版本出错的第一个错误的版本。&lt;/p&gt;
&lt;p&gt;你可以通过调用 &lt;code&gt;bool isBadVersion(version)&lt;/code&gt; 接口来判断版本号 &lt;code&gt;version&lt;/code&gt; 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定 n = 5，并且 version = 4 是第一个错误的版本。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;调用 isBadVersion(3) -&amp;gt; false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;调用 isBadVersion(5) -&amp;gt; true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;调用 isBadVersion(4) -&amp;gt; true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所以，4 是第一个错误的版本。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode——[108]Convert Sorted Array to Binary Search Tree将有序数组转换为二叉搜索树</title>
    <link href="http://yoursite.com/2018/06/07/leetcode-108/"/>
    <id>http://yoursite.com/2018/06/07/leetcode-108/</id>
    <published>2018-06-07T10:53:49.000Z</published>
    <updated>2019-03-21T02:35:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><a id="more"></a><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted array: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>递归构造BST，每次取数组中心位置的节点作为子树的根，第一次写的代码在递归调用时需要防止引用参数丢失，所以调用前需要先对root进行实例化，第二次经过修改不需要注意这点，两段代码跑了<strong>1ms</strong>，超过<strong>100%</strong>的Java提交，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Method_01  1ms  100.00%</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123; <span class="comment">//边界判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);  <span class="comment">// 先实例化，防止传递空指针</span></span><br><span class="line">        subArrayToBST(<span class="number">0</span>, nums.length - <span class="number">1</span>, root, nums);  <span class="comment">// 递归调用</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subArrayToBST</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, TreeNode root, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = (start + end) / <span class="number">2</span>;  <span class="comment">//取中心节点作为父节点</span></span><br><span class="line">        root.val = nums[index];</span><br><span class="line">        <span class="keyword">if</span> (start == end)&#123;  <span class="comment">// 递归结束条件</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start != index) &#123;  <span class="comment">// start == index时start &gt; index - 1</span></span><br><span class="line">            root.left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">            subArrayToBST(start, index - <span class="number">1</span>, root.left, nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index != end) &#123;  <span class="comment">// 同上</span></span><br><span class="line">            root.right = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">            subArrayToBST(index + <span class="number">1</span>, end, root.right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Method_02  1ms  100.00%</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123; <span class="comment">//边界判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subArrayToBST(<span class="number">0</span>, nums.length - <span class="number">1</span>, nums);  <span class="comment">// 递归调用，直接返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">subArrayToBST</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = (start + end) / <span class="number">2</span>;  <span class="comment">//取中心节点作为父节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[index]);</span><br><span class="line">        <span class="keyword">if</span> (start == end)&#123;  <span class="comment">// 递归结束条件</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start != index) &#123;  <span class="comment">// start == index时start &gt; index - 1</span></span><br><span class="line">            root.left = subArrayToBST(start, index - <span class="number">1</span>, nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index != end) &#123;  <span class="comment">// 同上</span></span><br><span class="line">            root.right = subArrayToBST(index + <span class="number">1</span>, end, nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过 1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定有序数组: [-10,-3,0,5,9],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   -3   9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /   /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -10  5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>gensim文本相似度分析</title>
    <link href="http://yoursite.com/2018/06/07/gensim-test/"/>
    <id>http://yoursite.com/2018/06/07/gensim-test/</id>
    <published>2018-06-07T09:09:05.000Z</published>
    <updated>2018-06-07T10:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>海量数据处理课程作业，对于给定的1998-1-人民日报语料，对于每篇文章，给出其余所有文章对它的相似度排序。为了完成这个作业，主要参考了这篇博客<a href="http://www.cnblogs.com/pinard/p/7160330.html" target="_blank" rel="noopener">http://www.cnblogs.com/pinard/p/7160330.html</a>。学习了一下gensim的基本用法，对NLP中的文本挖掘预处理有了简单的初步认识，接下来对实验过程进行总结。 </p><h1 id="word2vec原理"><a href="#word2vec原理" class="headerlink" title="word2vec原理"></a>word2vec原理</h1><h2 id="词向量基础"><a href="#词向量基础" class="headerlink" title="词向量基础"></a>词向量基础</h2><p>分为简单的1-of-N representation和Dristributed representation。</p><p>1-of-N representation就是有n个词，则用一个只有一个分量为1的n维向量表示，如图：</p><p><img src="/images/gensim-test/word-vector.png" alt=""></p><p align="center">图源：cnblogs.com/pinard</p><a id="more"></a><p>Queen对应的词向量则为(0, 1, 0, 0, 0)，King则为(1, 0, 0, 0, 0)，Women、Man、Child同理。这种表示方法十分简单明了，然而其显著缺点便是，当词汇表规模较大时，特别是在百万级别的文本挖掘中，则需要耗费大量的空间来存储每一个词的百万维的词向量，其总的规模则为1M^2=1T，这显然是不实际的。</p><p>Dristributed representation是利用机器学习，通过学习得到每个词在相对纬度小得多的词向量。这样便可以很好地解决1-of-N representation的存储问题。举个具体的例子如图所示：</p><p><img src="/images/gensim-test/word-vector-dis.png" alt=""></p><p align="center">图源：cnblogs.com/pinard</p><p>这样便可以用较短的词向量来表示海量的词汇，这些词向量的具体分量均可以用神经网络来学习得到。</p><h2 id="CBOW与Skip-Gram模型"><a href="#CBOW与Skip-Gram模型" class="headerlink" title="CBOW与Skip-Gram模型"></a>CBOW与Skip-Gram模型</h2><p>在训练神经网络模型得到词向量的时候，主要用了CBOW和Skip-Gram两种模型。简单地来说，基于三层前馈神经网络，对词向量进行学习，神经网络的输入是目标词汇的上下文词汇的词向量，可以定义上下文的窗口大小为4，那么就输入上下文的八个词汇的词向量，比如：</p><p><img src="/images/gensim-test/CBOW.png" alt=""></p><p align="center">图源：cnblogs.com/pinard</p><p>则输入为an、efficient、method、for、high、quality、distributed、vector的词向量。不考虑每个词到目标词汇的距离，每个词都是平等的，使用BP算法进行训练，输出函数使用softmax函数。神经网络输出为则为learning的词向量。</p><p>相反地，Skip-Gram模型则是以learning的词向量为输入，输出上下文八个词汇的词向量。</p><h2 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h2><p>基于对深度神经网络的学习我们知道，对神经网络的训练是十分耗时的，所以利用霍夫曼树来简化词向量生成的过程。 生成霍夫曼树的过程应该不用多讲了，就是将现有的权重最小的两个节点生成一棵树，根节点为叶子节点权重之和，然后继续寻找权重最小的两棵子树，直至所有节点生成一棵树。</p><p><img src="/images/gensim-test/huffman-tree.png" alt=""></p><p align="center">图源：cnblogs.com/pinard</p><p>一般得到霍夫曼树后我们会对叶子节点进行霍夫曼编码，由于权重高的叶子节点越靠近根节点，而权重低的叶子节点会远离根节点，这样我们的高权重节点编码值较短，而低权重值编码值较长。这保证的树的带权路径最短，也符合我们的信息论，即我们希望越常用的词拥有更短的编码。</p><h2 id="基于Hierarchical-Softmax的模型概述"><a href="#基于Hierarchical-Softmax的模型概述" class="headerlink" title="基于Hierarchical Softmax的模型概述"></a>基于Hierarchical Softmax的模型概述</h2><p>word2vec对神经网络进行了两次优化，首先不采取加权和的方式，而直接将输入向量取平均值作为隐含层神经元的激活函数。其次隐含层到输出层的softmax函数采取Huffman树来计算到输出层的映射，能够大大减少计算量。这种一层一层地计算训练模型就叫做Hierarchical Softmax。其结果为对一个词向量输入，它被划为左子树的概率记为P(-)，右子树的概率为P(+)=1-P(-)。回到基于Hierarchical Softmax的word2vec本身，我们的目标就是找到合适的所有节点的词向量和所有内部节点θ, 使训练样本达到最大似然。 </p><h1 id="使用gensim进行文本相似度分析"><a href="#使用gensim进行文本相似度分析" class="headerlink" title="使用gensim进行文本相似度分析"></a>使用gensim进行文本相似度分析</h1><h2 id="中文文本挖掘预处理"><a href="#中文文本挖掘预处理" class="headerlink" title="中文文本挖掘预处理"></a>中文文本挖掘预处理</h2><p>预处理一次为数据收集、除去数据非文本部分、中文分词、引入停用词、特征处理、建立分析模型。</p><p>数据收集主要有网上现有的语料，或者自己写爬虫爬数据两种途径。爬来的数据通常是HTML文件，包含大量非文本部分，比如HTML中的标签，需要对其进行清除。对于英文语料，通常只需要按空格、标点等特殊字符进行分词即可，而中文词汇之间没有像空格这样的明显标记，所以需要进行特殊的方法来分词，可以直接使用现有的Python分词包jieba来进行中文文本分词。分词之后，对于文本中的一些“着”、“和”、标点符号等无用词，进行清除，称为引入停用词。对于特征处理，则可以使用scikit-learning包来进行。有了每段文本的TF-IDF的特征向量，我们就可以利用这些数据建立分类模型，或者聚类模型了，或者进行主题模型的分析。 </p><h2 id="作业代码"><a href="#作业代码" class="headerlink" title="作业代码"></a>作业代码</h2><p>gensim是一个很好用的Python NLP的包，不光可以用于使用word2vec，还有很多其他的API可以用。用它来实现求本文相似度十分简单，跑了4s，直接贴代码了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3.6</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> gensim <span class="keyword">import</span> corpora, models, similarities</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">start = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># coding</span></span><br><span class="line">dateDic = defaultdict(list)  <span class="comment"># 文章日期作为键,文章内容['',''...]作为值</span></span><br><span class="line">dateIndexs = []  <span class="comment"># 保存文章索引</span></span><br><span class="line">tempIndex = <span class="string">""</span>  <span class="comment"># 防止添加重复的索引至dateIndexs中</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"199801_clear.txt"</span>, <span class="string">"r"</span>, encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        <span class="keyword">if</span> line.strip():</span><br><span class="line">            words = line.split()</span><br><span class="line">            dateId = words[<span class="number">0</span>].rsplit(<span class="string">"-"</span>, <span class="number">1</span>)[<span class="number">0</span>]  <span class="comment"># 提取文章日期作为编号，19980101-01-001-001</span></span><br><span class="line">            dateDic[dateId] += words[<span class="number">1</span>::]  <span class="comment"># 去除文章日期字符串</span></span><br><span class="line">            <span class="keyword">if</span> tempIndex != dateId:  <span class="comment"># 去除重复的日期索引</span></span><br><span class="line">                tempIndex = dateId</span><br><span class="line">                dateIndexs.append(tempIndex)</span><br><span class="line">train_documents = []  <span class="comment"># 训练语料集</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> dateDic:</span><br><span class="line">    train_documents.append(dateDic[d])  <span class="comment"># [[],[],[]]...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除无用词，停用词</span></span><br><span class="line">texts = [[word <span class="keyword">for</span> word <span class="keyword">in</span> document <span class="keyword">if</span> <span class="string">'/w'</span> <span class="keyword">not</span> <span class="keyword">in</span> word <span class="keyword">and</span> <span class="string">'/y'</span> <span class="keyword">not</span> <span class="keyword">in</span> word <span class="keyword">and</span> <span class="string">'/u'</span> <span class="keyword">not</span> <span class="keyword">in</span> word <span class="keyword">and</span> <span class="string">'/c'</span> <span class="keyword">not</span> <span class="keyword">in</span> word]</span><br><span class="line">         <span class="keyword">for</span> document <span class="keyword">in</span> train_documents]</span><br><span class="line"><span class="comment"># 删除只出现一词的词</span></span><br><span class="line">frequency = defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> text <span class="keyword">in</span> texts:</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> text:</span><br><span class="line">        frequency[token] += <span class="number">1</span></span><br><span class="line">texts = [[token <span class="keyword">for</span> token <span class="keyword">in</span> text <span class="keyword">if</span> frequency[token] &gt; <span class="number">1</span>] <span class="keyword">for</span> text <span class="keyword">in</span> texts]  <span class="comment"># texts为预处理后的最终语料集[[],[],[]...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立词袋doc2bow模型</span></span><br><span class="line">dictionary = corpora.Dictionary(texts)</span><br><span class="line">corpus = [dictionary.doc2bow(text) <span class="keyword">for</span> text <span class="keyword">in</span> texts]</span><br><span class="line"><span class="comment"># 依据词袋模型，计算单词的tf-idf值</span></span><br><span class="line">tfidf = models.TfidfModel(corpus)</span><br><span class="line">corpus_tfidf = tfidf[corpus]</span><br><span class="line"></span><br><span class="line">similarity = similarities.Similarity(<span class="string">'Similarity-tfidf-index'</span>, corpus_tfidf, num_features=<span class="number">99999</span>)</span><br><span class="line">similarity.num_best = <span class="number">30</span>  <span class="comment"># 最相近的30篇文档</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前100篇文档</span></span><br><span class="line">corpus_pre100 = [dictionary.doc2bow(text) <span class="keyword">for</span> text <span class="keyword">in</span> texts[<span class="number">0</span>:<span class="number">100</span>]]</span><br><span class="line">corpus_tfidf = tfidf[corpus_pre100]</span><br><span class="line">result_sim = similarity[corpus_tfidf]</span><br><span class="line">elapsed = (time.clock() - start)</span><br><span class="line">print(<span class="string">"Time used:"</span>, int(elapsed), <span class="string">"s"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果</span></span><br><span class="line">result_csv = pd.DataFrame(result_sim)</span><br><span class="line">result_csv.to_csv(<span class="string">"result.csv"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;海量数据处理课程作业，对于给定的1998-1-人民日报语料，对于每篇文章，给出其余所有文章对它的相似度排序。为了完成这个作业，主要参考了这篇博客&lt;a href=&quot;http://www.cnblogs.com/pinard/p/7160330.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/pinard/p/7160330.html&lt;/a&gt;。学习了一下gensim的基本用法，对NLP中的文本挖掘预处理有了简单的初步认识，接下来对实验过程进行总结。 &lt;/p&gt;
&lt;h1 id=&quot;word2vec原理&quot;&gt;&lt;a href=&quot;#word2vec原理&quot; class=&quot;headerlink&quot; title=&quot;word2vec原理&quot;&gt;&lt;/a&gt;word2vec原理&lt;/h1&gt;&lt;h2 id=&quot;词向量基础&quot;&gt;&lt;a href=&quot;#词向量基础&quot; class=&quot;headerlink&quot; title=&quot;词向量基础&quot;&gt;&lt;/a&gt;词向量基础&lt;/h2&gt;&lt;p&gt;分为简单的1-of-N representation和Dristributed representation。&lt;/p&gt;
&lt;p&gt;1-of-N representation就是有n个词，则用一个只有一个分量为1的n维向量表示，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/gensim-test/word-vector.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图源：cnblogs.com/pinard&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>leetcode——[102]Binary Tree Level Order Traversal二叉树的层次遍历</title>
    <link href="http://yoursite.com/2018/06/04/leetcode-102/"/>
    <id>http://yoursite.com/2018/06/04/leetcode-102/</id>
    <published>2018-06-04T02:18:51.000Z</published>
    <updated>2019-03-21T02:34:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its level order traversal as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>题目要求返回一个嵌套链表List<list<integer>&gt;，按层次输出，则需要将不同层次的节点保存在不同的子链表中，那么使用队列来进行层次遍历时，需要用两个队列，当前队列cur和一个下一层的队列sub，访问当前队列时，将各节点的子节点入列到下一层队列中，在当前层遍历结束后，交换cur和sub，下一次循环遍历下一层节点。</list<integer></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Method_01  2ms  84.73%</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;  <span class="comment">//边界判断</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Deque&lt;TreeNode&gt; cur = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//队列保存一层        </span></span><br><span class="line">    Deque&lt;TreeNode&gt; sub = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//队列保存下一层</span></span><br><span class="line">    Deque&lt;TreeNode&gt; exc;</span><br><span class="line"></span><br><span class="line">    TreeNode node;</span><br><span class="line">    cur.addLast(root);  <span class="comment">//先保存根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!cur.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; layout = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">//保存一层的节点</span></span><br><span class="line">        <span class="keyword">while</span>(!cur.isEmpty()) &#123;</span><br><span class="line">            node = cur.removeFirst();   <span class="comment">//弹出前面第一个节点</span></span><br><span class="line">            layout.add(node.val);       <span class="comment">//添加到输出集合中</span></span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;    <span class="comment">//把弹出的节点的左节点加入下一层队列</span></span><br><span class="line">                sub.addLast(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;   <span class="comment">//把弹出的节点的右节点加入下一层队列</span></span><br><span class="line">                sub.addLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exc = cur;       <span class="comment">//交换</span></span><br><span class="line">        cur = sub;            </span><br><span class="line">        sub = exc;</span><br><span class="line"></span><br><span class="line">        result.add(layout);  <span class="comment">//添加到结果集里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
&lt;p&gt;例如:&lt;br&gt;给定二叉树: &lt;code&gt;[3,9,20,null,null,15,7]&lt;/code&gt;,&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9  20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /  \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 15   7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回其层次遍历结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [9,20],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [15,7]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的层次遍历、二叉树的生成、求深度、统计节点数</title>
    <link href="http://yoursite.com/2018/06/04/tree-traverse-01/"/>
    <id>http://yoursite.com/2018/06/04/tree-traverse-01/</id>
    <published>2018-06-04T02:06:45.000Z</published>
    <updated>2018-06-06T15:30:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在上次基本遍历后，总结一下二叉树的层次遍历、二叉树的生成、求节点深度、统计节点数，二叉树的结构定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><p>使用队列进行层次遍历，先将节点入列，访问节点时出列，并将子节点入列，循环至队列为空，则遍历结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;  <span class="comment">// 边界判断</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">// 队列</span></span><br><span class="line">    TreeNode node;  <span class="comment">// 将要访问的节点变量</span></span><br><span class="line">    que.addLast(root);  <span class="comment">// 先保存根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty()) &#123;</span><br><span class="line">        node = que.removeFirst();</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;  <span class="comment">// 左子节点不为空则入列</span></span><br><span class="line">            que.addLast(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;  <span class="comment">// 右子节点不为空则入列</span></span><br><span class="line">            que.addLast(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.val);  <span class="comment">// 访问当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的生成"><a href="#二叉树的生成" class="headerlink" title="二叉树的生成"></a>二叉树的生成</h1><p>用Scanner接收输入，节点用空格“ ”分离，”#”代表空节点，利用前序遍历生成二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTree</span><span class="params">(Scanner scanner， TreeNode root)</span> </span>&#123;</span><br><span class="line">    String val = scanner.next();</span><br><span class="line">    <span class="keyword">if</span> (val.equals(<span class="string">"#"</span>)) &#123;  <span class="comment">// #置空</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        root.val = Integer.valueOf(val);</span><br><span class="line">        createTree(scanner, root.left);  <span class="comment">// 递归生成左右子树</span></span><br><span class="line">        createTree(scanner, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求节点深度"><a href="#求节点深度" class="headerlink" title="求节点深度"></a>求节点深度</h1><p>递归求深度，返回最大子节点深度加一，子节点为空则返回0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">depthOfNode</span><span class="params">(TreeNode parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lDepth = depthOfNode(parent.left);</span><br><span class="line">    <span class="keyword">int</span> rDepth = depthOfNode(parent.right);</span><br><span class="line">    <span class="keyword">return</span> lDepth &gt; rDepth ? lDepth + <span class="number">1</span> : rDepth + <span class="number">1</span>;  <span class="comment">// 返回较大子树深度+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="统计节点数"><a href="#统计节点数" class="headerlink" title="统计节点数"></a>统计节点数</h1><p>与求节点深度类似，递归求解，返回子节点数和+1，子节点为空则返回0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countOfNodes</span><span class="params">(TreeNode parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lCount = countOfNodes(parent.left);</span><br><span class="line">    <span class="keyword">int</span> rCount = countOfNodes(parent.right);</span><br><span class="line">    <span class="keyword">return</span> lCount + rCount + <span class="number">1</span>;  <span class="comment">// 返回子树节点数和+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在上次基本遍历后，总结一下二叉树的层次遍历、二叉树的生成、求节点深度、统计节点数，二叉树的结构定义为：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Definition for a binary tree node.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        val = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>8种基础排序方法总结</title>
    <link href="http://yoursite.com/2018/05/29/sort-methods/"/>
    <id>http://yoursite.com/2018/05/29/sort-methods/</id>
    <published>2018-05-29T08:14:50.000Z</published>
    <updated>2018-05-29T08:16:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>在要排序的一组数中，假设前面(n-1)[n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p><p>算法描述：</p><p>一般来说，<strong>插入排序</strong>都采用in-place（即只需用到O(1)的额外空间的排序）在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><a id="more"></a><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将arr[i] 插入到arr[0]...arr[i - 1]中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++ ) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"><span class="keyword">int</span> j = i - <span class="number">1</span>;  </span><br><span class="line"><span class="comment">//如果将赋值放到下一行的for循环内, 会导致在第10行出现j未声明的错误</span></span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j-- ) &#123;</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">&#125;</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(lst) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(lst)):</span><br><span class="line">        temp = lst[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> temp &lt; lst[j]:</span><br><span class="line">            lst[j + <span class="number">1</span>] = lst[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        lst[j + <span class="number">1</span>] = temp</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>如果目标是把n个元素的序列升序排列，那么采用<strong>插入排序</strong>存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需<strong>n-1</strong>次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有<strong>(1/2)n(n-1)</strong>次。<strong>插入排序</strong>的赋值操作是比较操作的次数减去<strong>n-1</strong>次，（因为<strong>n-1</strong>次循环中，每一次循环的比较都比赋值多一个，多在最后那一次比较并不带来赋值）。平均来说<strong>插入排序</strong>算法复杂度为O(n^2)。因而，<strong>插入排序</strong>不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知輸入元素大致上按照順序排列，那么<strong>插入排序</strong>还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。 </p><h1 id="2-希尔排序"><a href="#2-希尔排序" class="headerlink" title="2.希尔排序"></a>2.希尔排序</h1><h2 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h2><p><strong>希尔排序</strong>，也称<strong>递减增量排序算法</strong>，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><p>算法描述：</p><ol><li>先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序</li><li>然后取 d2(d2 &lt; d1)</li><li>重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。</li></ol><h2 id="Java实现-1"><a href="#Java实现-1" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">1</span>, i, j, len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>)</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...</span></span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python实现-1"><a href="#Python实现-1" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    n = len(list)</span><br><span class="line">    <span class="comment"># 初始步长</span></span><br><span class="line">    gap = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gap &lt; n // <span class="number">3</span></span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            <span class="comment"># 每个步长进行插入排序</span></span><br><span class="line">            temp = list[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 插入排序</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> list[j - gap] &gt; temp:</span><br><span class="line">                list[j] = list[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            list[j] = temp</span><br><span class="line">        <span class="comment"># 得到新的步长</span></span><br><span class="line">        gap = gap // <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>希尔排序是优化的插入排序，比O(n^2)低。</p><h1 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h1><h2 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h2><p>在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</p><h2 id="Java实现-2"><a href="#Java实现-2" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, min, temp, len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//未排序序列中最小数据数组下标</span></span><br><span class="line">        min = i;</span><br><span class="line">        <span class="comment">//在未排序元素中继续寻找最小元素，并保存其下标</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)｛</span><br><span class="line">            <span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最小元素放到已排序序列的末尾</span></span><br><span class="line">        temp = arr[min]; </span><br><span class="line">        arr[min] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python实现-2"><a href="#Python实现-2" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(L)</span>:</span></span><br><span class="line">    N = len(L)</span><br><span class="line">    exchanges_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N<span class="number">-1</span>):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, N):</span><br><span class="line">            <span class="keyword">if</span> L[min_index] &gt; L[j]:</span><br><span class="line">                min_index = j</span><br><span class="line">        <span class="keyword">if</span> min_index != i:</span><br><span class="line">            L[min_index], L[i] = L[i], L[min_index]</span><br><span class="line">        exchanges_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>选择排序的<strong>交换操作</strong>介于<strong>0</strong>和<strong>n-1</strong>次之间。选择排序的<strong>比较操作</strong>为<strong>n(n-1)/2</strong>次。选择排序的<strong>赋值操作</strong>介于<strong>0</strong>和<strong>3(n-1)</strong>次之间。</p><p>比较次数<strong>O(n^2)</strong>，比较次数与关键字的初始状态无关，总的比较次数<strong>N=(n-1)+(n-2)+…+1=n(n-1)/2</strong>。交换次数<strong>O(n)</strong>，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换<strong>n-1</strong>次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，<strong>n</strong>值较小时，选择排序比冒泡排序快。</p><p>原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。</p><h1 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4.堆排序"></a>4.堆排序</h1><h2 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h2><p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。</p><p>堆的定义如下：具有n个元素的序列（h1,h2,…,hn)，当且仅当满足（hi&gt;=h2i,hi&gt;=2i+1）或（hi&lt;=h2i,hi&lt;=2i+1）(i=1,2,…,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</p><h2 id="Java实现-3"><a href="#Java实现-3" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  第一步：将数组堆化</span></span><br><span class="line"><span class="comment">     *  beginIndex = 第一个非叶子节点。</span></span><br><span class="line"><span class="comment">     *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span></span><br><span class="line"><span class="comment">     *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> beginIndex = (len - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = beginIndex; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        maxHeapify(i, len);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第二步：对堆化数据排序</span></span><br><span class="line"><span class="comment">     * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。</span></span><br><span class="line"><span class="comment">     * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。</span></span><br><span class="line"><span class="comment">     * 直至未排序的堆长度为 0。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        swap(<span class="number">0</span>, i);</span><br><span class="line">        maxHeapify(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整索引为 index 处的数据，使其符合堆的特性。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 需要堆化处理的数据的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len 未排序的堆（数组）的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> li = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左子节点索引</span></span><br><span class="line">    <span class="keyword">int</span> ri = li + <span class="number">1</span>;           <span class="comment">// 右子节点索引</span></span><br><span class="line">    <span class="keyword">int</span> cMax = li;             <span class="comment">// 子节点值最大索引，默认左子节点。</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(li &gt; len) <span class="keyword">return</span>;       <span class="comment">// 左子节点索引超出计算范围，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span>(ri &lt;= len &amp;&amp; arr[ri] &gt; arr[li]) <span class="comment">// 先判断左右子节点，哪个较大。</span></span><br><span class="line">        cMax = ri;</span><br><span class="line">    <span class="keyword">if</span>(arr[cMax] &gt; arr[index])&#123;</span><br><span class="line">        swap(cMax, index);      <span class="comment">// 如果父节点被子节点调换，</span></span><br><span class="line">        maxHeapify(cMax, len);  <span class="comment">// 则需要继续判断换下后的父节点是否符合堆的特性。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python实现-3"><a href="#Python实现-3" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(start, end)</span>:</span></span><br><span class="line">        <span class="string">"""最大堆调整"""</span></span><br><span class="line">        root = start</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            child = <span class="number">2</span> * root + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> child &gt; end:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> child + <span class="number">1</span> &lt;= end <span class="keyword">and</span> lst[child] &lt; lst[child + <span class="number">1</span>]:</span><br><span class="line">                child += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> lst[root] &lt; lst[child]:</span><br><span class="line">                lst[root], lst[child] = lst[child], lst[root]</span><br><span class="line">                root = child</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> xrange((len(lst) - <span class="number">2</span>) // <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        sift_down(start, len(lst) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 堆排序</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> xrange(len(lst) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        lst[<span class="number">0</span>], lst[end] = lst[end], lst[<span class="number">0</span>]</span><br><span class="line">        sift_down(<span class="number">0</span>, end - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>堆排序的平均<strong>时间复杂度</strong>为<strong>O(nlogn)</strong>，<strong>空间复杂度</strong>为<strong>O(1)</strong>。 </p><h1 id="5-冒泡排序"><a href="#5-冒泡排序" class="headerlink" title="5.冒泡排序"></a>5.冒泡排序</h1><h2 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h2><p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。 </p><h2 id="Java实现-4"><a href="#Java实现-4" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n次遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python实现-4"><a href="#Python实现-4" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sorted</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    new_list = list(iterable)</span><br><span class="line">    list_len = len(new_list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(list_len - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(list_len - <span class="number">1</span>, i, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> new_list[j] &lt; new_list[j - <span class="number">1</span>]:</span><br><span class="line">                new_list[j], new_list[j - <span class="number">1</span>] = new_list[j - <span class="number">1</span>], new_list[j]</span><br><span class="line">    <span class="keyword">return</span> new_list</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>冒泡排序总的平均时间复杂度为<strong>O(n^2)</strong>。</p><h1 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h1><h2 id="基本思想-5"><a href="#基本思想-5" class="headerlink" title="基本思想"></a>基本思想</h2><p>选择一个基准元素，通常选择第一个元素或者最后一个元素，通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素,此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。 </p><p>算法描述：</p><ol><li>从数列中挑出一个元素，称为”基准”（pivot），</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为<strong>分割（partition）</strong>操作。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><h2 id="Java实现-5"><a href="#Java实现-5" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head &gt;= tail || arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = head, j = tail, pivot = arr[(head + tail) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt; pivot) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = t;</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qSort(arr, head, j);</span><br><span class="line">    qSort(arr, i, tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python实现-5"><a href="#Python实现-5" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(lst, lo, hi)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lo &lt; hi:</span><br><span class="line">        p = partition(lst, lo, hi)</span><br><span class="line">        quicksort(lst, lo, p)</span><br><span class="line">        quicksort(lst, p+<span class="number">1</span>, hi)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(lst, lo, hi)</span>:</span></span><br><span class="line">    pivot = lst[hi<span class="number">-1</span>]</span><br><span class="line">    i = lo - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(lo, hi):</span><br><span class="line">        <span class="keyword">if</span> lst[j] &lt; pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            lst[i], lst[j] = lst[j], lst[i]</span><br><span class="line">    <span class="keyword">if</span> lst[hi<span class="number">-1</span>] &lt; lst[i+<span class="number">1</span>]:</span><br><span class="line">        lst[i+<span class="number">1</span>], lst[hi<span class="number">-1</span>] = lst[hi<span class="number">-1</span>], lst[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>快速排序的<strong>时间复杂度</strong>为<strong>O(nlogn)</strong>。 </p><h1 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7.归并排序"></a>7.归并排序</h1><h2 id="基本思想-6"><a href="#基本思想-6" class="headerlink" title="基本思想"></a>基本思想</h2><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 </p><h2 id="Java实现-6"><a href="#Java实现-6" class="headerlink" title="Java实现"></a>Java实现</h2><p>递归版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortRecursive</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] result, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line"><span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line"><span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">merge_sort_recursive(arr, result, start1, end1);</span><br><span class="line">merge_sort_recursive(arr, result, start2, end2);</span><br><span class="line"><span class="keyword">int</span> k = start;</span><br><span class="line"><span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">result[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line"><span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">result[k++] = arr[start1++];</span><br><span class="line"><span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">result[k++] = arr[start2++];</span><br><span class="line"><span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">arr[k] = result[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">mergeSortRecursive(arr, result, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span> block, start; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(block = <span class="number">1</span>; block &lt; len; block *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(start = <span class="number">0</span>; start &lt;len; start += <span class="number">2</span> * block) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = start;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + block) &lt; len ? (start + block) : len;</span><br><span class="line">            <span class="keyword">int</span> high = (start + <span class="number">2</span> * block) &lt; len ? (start + <span class="number">2</span> * block) : len;</span><br><span class="line">            <span class="comment">//两个块的起始下标及结束下标</span></span><br><span class="line">            <span class="keyword">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="keyword">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="comment">//开始对两个block进行归并排序</span></span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2) &#123;</span><br><span class="line">        result[low++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(start1 &lt; end1) &#123;</span><br><span class="line">        result[low++] = arr[start1++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(start2 &lt; end2) &#123;</span><br><span class="line">        result[low++] = arr[start2++];</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] temp = arr;</span><br><span class="line">        arr = result;</span><br><span class="line">        result = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    result = arr;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python实现-6"><a href="#Python实现-6" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(lst) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">        merged,left,right = deque(),deque(left),deque(right)</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="comment"># deque popleft is also O(1)</span></span><br><span class="line">            merged.append(left.popleft() <span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] <span class="keyword">else</span> right.popleft())  </span><br><span class="line">        merged.extend(right <span class="keyword">if</span> right <span class="keyword">else</span> left)</span><br><span class="line">        <span class="keyword">return</span> merged</span><br><span class="line"></span><br><span class="line">    middle = int(len(lst) // <span class="number">2</span>)</span><br><span class="line">    left = merge_sort(lst[:middle])</span><br><span class="line">    right = merge_sort(lst[middle:])</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>归并排序的<strong>时间复杂度</strong>为<strong>O(nlogn)</strong>。</p><h1 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8.基数排序"></a>8.基数排序</h1><h2 id="基本思想-7"><a href="#基本思想-7" class="headerlink" title="基本思想"></a>基本思想</h2><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。 </p><h2 id="Java实现-7"><a href="#Java实现-7" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] number, <span class="keyword">int</span> d)</span> </span>&#123;<span class="comment">//d表示最大的数有多少位</span></span><br><span class="line">    intk = <span class="number">0</span>;</span><br><span class="line">    intn = <span class="number">1</span>;</span><br><span class="line">    intm = <span class="number">1</span>; <span class="comment">//控制键值排序依据在哪一位</span></span><br><span class="line">    <span class="keyword">int</span>[][]temp = newint[<span class="number">10</span>][number.length]; <span class="comment">//数组的第一维表示可能的余数0-9</span></span><br><span class="line">    <span class="keyword">int</span>[]order = newint[<span class="number">10</span>]; <span class="comment">//数组orderp[i]用来表示该位是i的数的个数</span></span><br><span class="line">    <span class="keyword">while</span>(m &lt;= d) &#123;</span><br><span class="line">        <span class="keyword">for</span>(inti = <span class="number">0</span>; i &lt; number.length; i++) &#123;</span><br><span class="line">            intlsd = ((number[i] / n) % <span class="number">10</span>);</span><br><span class="line">            temp[lsd][order[lsd]] = number[i];</span><br><span class="line">            order[lsd]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(inti = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(order[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(intj = <span class="number">0</span>; j &lt; order[i]; j++) &#123;</span><br><span class="line">                    number[k] = temp[i][j];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            order[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n *= <span class="number">10</span>;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python实现-7"><a href="#Python实现-7" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radixSort</span><span class="params">(a, radix=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">"""a为整数列表， radix为基数"""</span></span><br><span class="line">    K = int(math.ceil(math.log(max(a)+<span class="number">1</span>, radix))) <span class="comment"># 用K位数可表示任意整数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, K+<span class="number">1</span>): <span class="comment"># K次循环</span></span><br><span class="line">        bucket = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(radix)] <span class="comment"># 不能用 [[]]*radix，否则相当于开了radix个完全相同的list对象</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> a:</span><br><span class="line">            bucket[val%(radix**i)//(radix**(i<span class="number">-1</span>))].append(val) <span class="comment"># 获得整数第K位数字（从低到高）</span></span><br><span class="line">        <span class="keyword">del</span> a[:]</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> bucket:</span><br><span class="line">            a.extend(each) <span class="comment"># 桶合并</span></span><br></pre></td></tr></table></figure><h2 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>基数排序的时间复杂度是<strong>O(kn)</strong>，其中<strong>n</strong>是排序元素个数，<strong>k</strong>是数字位数。注意这不是说这个时间复杂度一定优于<strong>O(nlogn)</strong>，<strong>k</strong>的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；<strong>k</strong>决定了进行多少轮处理，而<strong>n</strong>是每轮处理的操作数目。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-插入排序&quot;&gt;&lt;a href=&quot;#1-插入排序&quot; class=&quot;headerlink&quot; title=&quot;1.插入排序&quot;&gt;&lt;/a&gt;1.插入排序&lt;/h1&gt;&lt;h2 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h2&gt;&lt;p&gt;在要排序的一组数中，假设前面(n-1)[n&amp;gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。&lt;/p&gt;
&lt;p&gt;算法描述：&lt;/p&gt;
&lt;p&gt;一般来说，&lt;strong&gt;插入排序&lt;/strong&gt;都采用in-place（即只需用到O(1)的额外空间的排序）在数组上实现。具体算法描述如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从第一个元素开始，该元素可以认为已经被排序&lt;/li&gt;
&lt;li&gt;取出下一个元素，在已经排序的元素序列中从后向前扫描&lt;/li&gt;
&lt;li&gt;如果该元素（已排序）大于新元素，将该元素移到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤3，直到找到已排序的元素小于或者等于新元素的位置&lt;/li&gt;
&lt;li&gt;将新元素插入到该位置后&lt;/li&gt;
&lt;li&gt;重复步骤2~5&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动2018 Android校招编程题——用户喜好</title>
    <link href="http://yoursite.com/2018/05/22/bytedance-question/"/>
    <id>http://yoursite.com/2018/05/22/bytedance-question/</id>
    <published>2018-05-22T13:42:45.000Z</published>
    <updated>2018-06-04T02:20:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="用户喜好"><a href="#用户喜好" class="headerlink" title="用户喜好"></a>用户喜好</h2><p>为了不断优化推荐效果，今日头条每天要存储和处理海量数据。假设有这样一种场景：我们对用户按照它们的注册时间先后来标号，对于一类文章，每个用户都有不同的喜好值，我们会想知道某一段时间内注册的用户（标号相连的一批用户）中，有多少用户对这类文章喜好值为k。因为一些特殊的原因，不会出现一个查询的用户区间完全覆盖另一个查询的用户区间(不存在L1&lt;=L2&lt;=R2&lt;=R1)。</p><a id="more"></a><p><strong>输入描述:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入： 第1行为n代表用户的个数 第2行为n个整数，第i个代表用户标号为i的用户对某类文章的喜好度 第3行为一个正整数q代表查询的组数  第4行到第（3+q）行，每行包含3个整数l,r,k代表一组查询，即标号为l&lt;=i&lt;=r的用户中对这类文章喜好值为k的用户的个数。 数据范围n &lt;= 300000,q&lt;=300000 k是整型</span><br></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：一共q行，每行一个整数代表喜好值为k的用户的个数</span><br></pre></td></tr></table></figure><p><strong>输入例子1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 3 5</span><br><span class="line">3</span><br><span class="line">1 2 1</span><br><span class="line">2 4 5</span><br><span class="line">3 5 3</span><br></pre></td></tr></table></figure><p><strong>输出例子1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>例子说明1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">样例解释:</span><br><span class="line">有5个用户，喜好值为分别为1、2、3、3、5，</span><br><span class="line">第一组询问对于标号[1,2]的用户喜好值为1的用户的个数是1</span><br><span class="line">第二组询问对于标号[2,4]的用户喜好值为5的用户的个数是0</span><br><span class="line">第三组询问对于标号[3,5]的用户喜好值为3的用户的个数是2</span><br></pre></td></tr></table></figure><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>首先用hashMap记录每个喜好值对应的用户id，将用户id记录在一个list中，然后查询目标喜好值的list，记录list中满足条件的id个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();<span class="comment">//总人数</span></span><br><span class="line">        HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录所有喜好值对应用户的id保存到map中，用户id保存到ArrayList中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = scanner.nextInt();</span><br><span class="line">            ArrayList&lt;Integer&gt; list = map.getOrDefault(cur, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            list.add(i);</span><br><span class="line">            map.put(cur, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> times = scanner.nextInt();<span class="comment">//记录查询次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录用户个数</span></span><br><span class="line">            <span class="keyword">int</span> start = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> end = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> target = scanner.nextInt();</span><br><span class="line">            ArrayList&lt;Integer&gt; list = map.get(target);</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> a :</span><br><span class="line">                        list) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a + <span class="number">1</span> &gt;= start &amp;&amp; a + <span class="number">1</span> &lt;= end) &#123;<span class="comment">//用户id在区间内</span></span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;h2 id=&quot;用户喜好&quot;&gt;&lt;a href=&quot;#用户喜好&quot; class=&quot;headerlink&quot; title=&quot;用户喜好&quot;&gt;&lt;/a&gt;用户喜好&lt;/h2&gt;&lt;p&gt;为了不断优化推荐效果，今日头条每天要存储和处理海量数据。假设有这样一种场景：我们对用户按照它们的注册时间先后来标号，对于一类文章，每个用户都有不同的喜好值，我们会想知道某一段时间内注册的用户（标号相连的一批用户）中，有多少用户对这类文章喜好值为k。因为一些特殊的原因，不会出现一个查询的用户区间完全覆盖另一个查询的用户区间(不存在L1&amp;lt;=L2&amp;lt;=R2&amp;lt;=R1)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历总结</title>
    <link href="http://yoursite.com/2018/05/21/tree-traverse/"/>
    <id>http://yoursite.com/2018/05/21/tree-traverse/</id>
    <published>2018-05-21T13:42:27.000Z</published>
    <updated>2018-06-04T01:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这次首先总结二叉树的前序、中序、后序、层次遍历的递归与非递归实现。</p><p>下次总结二叉树的查找、求二叉树的深度、统计节点个数与节点比较的递归实现。</p><a id="more"></a><p>二叉树的结构定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><p>前序遍历的递归实现，中序遍历、后序遍历的递归实现同理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(t.val);</span><br><span class="line">        preOrder(t.left);</span><br><span class="line">        preOrder(t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前序遍历的非递归实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//初始化栈</span></span><br><span class="line">    TreeNode root = t;<span class="comment">//保存当前节点</span></span><br><span class="line">    <span class="comment">//当前节点与栈不同时为空，则进行循环</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span> || !nodeStack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//找到最左端节点</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(root.val);<span class="comment">//输出当前节点</span></span><br><span class="line">            nodeStack.push(root);<span class="comment">//当前节点入栈</span></span><br><span class="line">            root = root.left;<span class="comment">//访问左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树遍历后，出栈访问右子树</span></span><br><span class="line">        <span class="keyword">if</span> (!nodeStack.isEmpty()) &#123;</span><br><span class="line">            root = nodeStack.pop();</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p>中序遍历的递归实现，同理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">medOrder</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>)&#123;</span><br><span class="line">        preOrder(t.left);</span><br><span class="line">        System.out.println();</span><br><span class="line">        preOrder(t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历的非递归实现，与前序遍历不同的就是在找最左端节点时不输出当前节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">medOrder</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//初始化栈</span></span><br><span class="line">    TreeNode root = t;<span class="comment">//保存当前节点</span></span><br><span class="line">    <span class="comment">//同样，当前节点与栈不同时为空，则循环</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span> || !nodeStack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//寻找最左节点</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nodeStack.push(root);<span class="comment">//当前节点入栈</span></span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!nodeStack.isEmpty()) &#123;</span><br><span class="line">            root = nodeStack.pop();</span><br><span class="line">            System.out.println(root.val);<span class="comment">//输出当前节点</span></span><br><span class="line">            root = root.right;<span class="comment">//进入右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><p>后序遍历的递归实现，同理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>)&#123;</span><br><span class="line">        preOrder(t.left);</span><br><span class="line">        preOrder(t.right);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历的非递归实现，需要注意的是得先访问父节点的两个子节点之后才能访问父节点，需要使用一个last节点来记录上一次访问的节点，判断是否是当前节点的右子节点，若是，则说明当前左右子树均已访问，则输出当前节点，否则访问其右子树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; treeNodeStack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode node = root;<span class="comment">//记录当前节点</span></span><br><span class="line">    TreeNode lastVisit = root;<span class="comment">//记录当前节点的右子树</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !treeNodeStack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//找到最左边的节点</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            treeNodeStack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看当前栈顶元素</span></span><br><span class="line">        node = treeNodeStack.peek();</span><br><span class="line">        <span class="comment">//如果其右子树也为空，或者右子树已经访问</span></span><br><span class="line">        <span class="comment">//则可以直接输出当前节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span> || node.right == lastVisit) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">            treeNodeStack.pop();</span><br><span class="line">            lastVisit = node;</span><br><span class="line">            node = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则，继续遍历右子树</span></span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这次首先总结二叉树的前序、中序、后序、层次遍历的递归与非递归实现。&lt;/p&gt;
&lt;p&gt;下次总结二叉树的查找、求二叉树的深度、统计节点个数与节点比较的递归实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode——[237]Delete Node in a Linked List删除链表中的节点</title>
    <link href="http://yoursite.com/2018/05/11/leetcode-237/"/>
    <id>http://yoursite.com/2018/05/11/leetcode-237/</id>
    <published>2018-05-10T17:03:37.000Z</published>
    <updated>2019-03-21T02:35:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾的）节点，您将只被给予要求被删除的节点。</p><p>比如：假设该链表为 <code>1 -&gt; 2 -&gt; 3 -&gt; 4</code> ，给定您的为该链表中值为 <code>3</code> 的第三个节点，那么在调用了您的函数之后，该链表则应变成 <code>1 -&gt; 2 -&gt; 4</code> 。</p><a id="more"></a><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p><p>Supposed the linked list is <code>1 -&gt; 2 -&gt; 3 -&gt; 4</code> and you are given the third node with value <code>3</code>, the linked list should become <code>1 -&gt; 2 -&gt; 4</code> after calling your function.</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>这道题好像就是删除第一个节点，就直接将头节点的值赋为第二个节点的值，然后next指向第三个节点就好了，这道题似乎没有什么意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;请编写一个函数，使其可以删除某个链表中给定的（非末尾的）节点，您将只被给予要求被删除的节点。&lt;/p&gt;
&lt;p&gt;比如：假设该链表为 &lt;code&gt;1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4&lt;/code&gt; ，给定您的为该链表中值为 &lt;code&gt;3&lt;/code&gt; 的第三个节点，那么在调用了您的函数之后，该链表则应变成 &lt;code&gt;1 -&amp;gt; 2 -&amp;gt; 4&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode——[088]Merge Sorted Array合并两个有序数组</title>
    <link href="http://yoursite.com/2018/05/09/leetcode-088/"/>
    <id>http://yoursite.com/2018/05/09/leetcode-088/</id>
    <published>2018-05-09T10:50:46.000Z</published>
    <updated>2019-03-21T02:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使得 <em>num1</em> 成为一个有序数组。</p><p><strong>说明:</strong></p><ul><li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em>。</li><li>你可以假设 <em>nums1</em> 有足够的空间（空间大小大于或等于 <em>m + n</em>）来保存 <em>nums2</em> 中的元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><a id="more"></a><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p><p><strong>Note:</strong></p><ul><li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li><li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><h2 id="从后往前填充"><a href="#从后往前填充" class="headerlink" title="从后往前填充"></a>从后往前填充</h2><p>从后往前填充，即从最大，到最小进行填充，能够保证不需要额外空间，时间复杂度为O(m+n)，这段代码跑了<strong>3ms</strong>，超过了100%的java提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Method_01  3ms  100%</span></span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, index = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt;= nums2[j]) &#123;</span><br><span class="line">                nums1[index--] = nums1[i--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[index--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[index--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定两个有序整数数组 &lt;em&gt;nums1&lt;/em&gt; 和 &lt;em&gt;nums2&lt;/em&gt;，将 &lt;em&gt;nums2&lt;/em&gt; 合并到 &lt;em&gt;nums1&lt;/em&gt; 中&lt;em&gt;，&lt;/em&gt;使得 &lt;em&gt;num1&lt;/em&gt; 成为一个有序数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 &lt;em&gt;nums1&lt;/em&gt; 和 &lt;em&gt;nums2&lt;/em&gt; 的元素数量分别为 &lt;em&gt;m&lt;/em&gt; 和 &lt;em&gt;n&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;你可以假设 &lt;em&gt;nums1&lt;/em&gt; 有足够的空间（空间大小大于或等于 &lt;em&gt;m + n&lt;/em&gt;）来保存 &lt;em&gt;nums2&lt;/em&gt; 中的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums1 = [1,2,3,0,0,0], m = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums2 = [2,5,6],       n = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2,2,3,5,6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
